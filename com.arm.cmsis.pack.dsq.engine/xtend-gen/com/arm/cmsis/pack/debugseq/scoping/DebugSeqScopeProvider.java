/**
 * generated by Xtext 2.10.0
 */
package com.arm.cmsis.pack.debugseq.scoping;

import com.arm.cmsis.pack.debugseq.debugSeq.Block;
import com.arm.cmsis.pack.debugseq.debugSeq.CodeBlock;
import com.arm.cmsis.pack.debugseq.debugSeq.Control;
import com.arm.cmsis.pack.debugseq.debugSeq.DebugSeqModel;
import com.arm.cmsis.pack.debugseq.debugSeq.DebugSeqPackage;
import com.arm.cmsis.pack.debugseq.debugSeq.Expression;
import com.arm.cmsis.pack.debugseq.debugSeq.Sequence;
import com.arm.cmsis.pack.debugseq.debugSeq.Statement;
import com.arm.cmsis.pack.debugseq.debugSeq.VariableDeclaration;
import com.arm.cmsis.pack.debugseq.scoping.AbstractDebugSeqScopeProvider;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import java.util.Arrays;
import java.util.List;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.xtext.scoping.IScope;
import org.eclipse.xtext.scoping.Scopes;
import org.eclipse.xtext.xbase.lib.CollectionLiterals;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom scoping description.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#scoping
 * on how and when to use it.
 */
@SuppressWarnings("all")
public class DebugSeqScopeProvider extends AbstractDebugSeqScopeProvider {
  @Override
  public IScope getScope(final EObject context, final EReference r) {
    IScope _xifexpression = null;
    if (((context instanceof Expression) && Objects.equal(r, DebugSeqPackage.Literals.VARIABLE_REF__VARIABLE))) {
      _xifexpression = this.symbolsDefinedBefore(context.eContainer(), context);
    } else {
      _xifexpression = super.getScope(context, r);
    }
    return _xifexpression;
  }
  
  protected IScope _symbolsDefinedBefore(final EObject cont, final EObject o) {
    return this.symbolsDefinedBefore(cont.eContainer(), o.eContainer());
  }
  
  protected IScope _symbolsDefinedBefore(final DebugSeqModel dsm, final EObject o) {
    return Scopes.scopeFor(
      Iterables.<VariableDeclaration>filter(dsm.getDebugvars().getStatements(), VariableDeclaration.class));
  }
  
  protected IScope _symbolsDefinedBefore(final Sequence seq, final EObject o) {
    final Function1<Block, Iterable<VariableDeclaration>> _function = (Block it) -> {
      return Iterables.<VariableDeclaration>filter(it.getStatements(), VariableDeclaration.class);
    };
    return Scopes.scopeFor(
      Iterables.<VariableDeclaration>concat(IterableExtensions.<Block, Iterable<VariableDeclaration>>map(this.blocksDeclaredBefore(seq.getCodeblocks(), o), _function)), 
      this.symbolsDefinedBefore(seq.eContainer(), o.eContainer()));
  }
  
  protected IScope _symbolsDefinedBefore(final Block b, final EObject o) {
    return Scopes.scopeFor(
      this.variablesDeclaredBefore(b.getStatements(), o), 
      this.symbolsDefinedBefore(b.eContainer(), o.eContainer()));
  }
  
  protected IScope _symbolsDefinedBefore(final Control c, final EObject o) {
    final Function1<Block, Iterable<VariableDeclaration>> _function = (Block it) -> {
      return Iterables.<VariableDeclaration>filter(it.getStatements(), VariableDeclaration.class);
    };
    return Scopes.scopeFor(
      Iterables.<VariableDeclaration>concat(IterableExtensions.<Block, Iterable<VariableDeclaration>>map(this.blocksDeclaredBefore(c.getCodeblocks(), o), _function)), 
      this.symbolsDefinedBefore(c.eContainer(), o.eContainer()));
  }
  
  private Iterable<Block> blocksDeclaredBefore(final List<CodeBlock> list, final EObject o) {
    Iterable<Block> _xifexpression = null;
    if (((o instanceof Block) || (o instanceof Control))) {
      _xifexpression = Iterables.<Block>filter(list.subList(0, list.indexOf(o)), Block.class);
    } else {
      _xifexpression = CollectionLiterals.<Block>newArrayList();
    }
    return _xifexpression;
  }
  
  private Iterable<VariableDeclaration> variablesDeclaredBefore(final List<Statement> list, final EObject o) {
    return Iterables.<VariableDeclaration>filter(list.subList(0, list.indexOf(o)), VariableDeclaration.class);
  }
  
  public IScope symbolsDefinedBefore(final EObject b, final EObject o) {
    if (b instanceof Block) {
      return _symbolsDefinedBefore((Block)b, o);
    } else if (b instanceof Control) {
      return _symbolsDefinedBefore((Control)b, o);
    } else if (b instanceof DebugSeqModel) {
      return _symbolsDefinedBefore((DebugSeqModel)b, o);
    } else if (b instanceof Sequence) {
      return _symbolsDefinedBefore((Sequence)b, o);
    } else if (b != null) {
      return _symbolsDefinedBefore(b, o);
    } else {
      throw new IllegalArgumentException("Unhandled parameter types: " +
        Arrays.<Object>asList(b, o).toString());
    }
  }
}
