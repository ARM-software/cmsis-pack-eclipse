/**
 * generated by Xtext 2.10.0
 */
package com.arm.cmsis.pack.debugseq.validation;

import com.arm.cmsis.pack.debugseq.debugSeq.And;
import com.arm.cmsis.pack.debugseq.debugSeq.Assignment;
import com.arm.cmsis.pack.debugseq.debugSeq.BitAnd;
import com.arm.cmsis.pack.debugseq.debugSeq.BitOr;
import com.arm.cmsis.pack.debugseq.debugSeq.BitXor;
import com.arm.cmsis.pack.debugseq.debugSeq.Block;
import com.arm.cmsis.pack.debugseq.debugSeq.Comparison;
import com.arm.cmsis.pack.debugseq.debugSeq.DapDelay;
import com.arm.cmsis.pack.debugseq.debugSeq.DapJtagSequence;
import com.arm.cmsis.pack.debugseq.debugSeq.DapSwjClock;
import com.arm.cmsis.pack.debugseq.debugSeq.DapSwjPins;
import com.arm.cmsis.pack.debugseq.debugSeq.DapSwjSequence;
import com.arm.cmsis.pack.debugseq.debugSeq.DapWriteABORT;
import com.arm.cmsis.pack.debugseq.debugSeq.DebugSeqModel;
import com.arm.cmsis.pack.debugseq.debugSeq.DebugSeqPackage;
import com.arm.cmsis.pack.debugseq.debugSeq.Div;
import com.arm.cmsis.pack.debugseq.debugSeq.Equality;
import com.arm.cmsis.pack.debugseq.debugSeq.Expression;
import com.arm.cmsis.pack.debugseq.debugSeq.LoadDebugInfo;
import com.arm.cmsis.pack.debugseq.debugSeq.Message;
import com.arm.cmsis.pack.debugseq.debugSeq.Minus;
import com.arm.cmsis.pack.debugseq.debugSeq.Mul;
import com.arm.cmsis.pack.debugseq.debugSeq.Not;
import com.arm.cmsis.pack.debugseq.debugSeq.Or;
import com.arm.cmsis.pack.debugseq.debugSeq.Plus;
import com.arm.cmsis.pack.debugseq.debugSeq.Query;
import com.arm.cmsis.pack.debugseq.debugSeq.QueryValue;
import com.arm.cmsis.pack.debugseq.debugSeq.Read16;
import com.arm.cmsis.pack.debugseq.debugSeq.Read32;
import com.arm.cmsis.pack.debugseq.debugSeq.Read64;
import com.arm.cmsis.pack.debugseq.debugSeq.Read8;
import com.arm.cmsis.pack.debugseq.debugSeq.ReadAP;
import com.arm.cmsis.pack.debugseq.debugSeq.ReadDP;
import com.arm.cmsis.pack.debugseq.debugSeq.Sequence;
import com.arm.cmsis.pack.debugseq.debugSeq.SequenceCall;
import com.arm.cmsis.pack.debugseq.debugSeq.Shift;
import com.arm.cmsis.pack.debugseq.debugSeq.Statement;
import com.arm.cmsis.pack.debugseq.debugSeq.Ternary;
import com.arm.cmsis.pack.debugseq.debugSeq.VariableDeclaration;
import com.arm.cmsis.pack.debugseq.debugSeq.VariableRef;
import com.arm.cmsis.pack.debugseq.debugSeq.Write16;
import com.arm.cmsis.pack.debugseq.debugSeq.Write32;
import com.arm.cmsis.pack.debugseq.debugSeq.Write64;
import com.arm.cmsis.pack.debugseq.debugSeq.Write8;
import com.arm.cmsis.pack.debugseq.debugSeq.WriteAP;
import com.arm.cmsis.pack.debugseq.debugSeq.WriteDP;
import com.arm.cmsis.pack.debugseq.typing.DebugSeqType;
import com.arm.cmsis.pack.debugseq.typing.DebugSeqTypeProvider;
import com.arm.cmsis.pack.debugseq.util.DebugSeqUtil;
import com.arm.cmsis.pack.debugseq.validation.AbstractDebugSeqValidator;
import com.google.common.base.Objects;
import com.google.common.collect.Iterables;
import com.google.inject.Inject;
import java.util.HashSet;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EReference;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.xtext.EcoreUtil2;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Extension;
import org.eclipse.xtext.xbase.lib.Functions.Function1;
import org.eclipse.xtext.xbase.lib.IterableExtensions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class DebugSeqValidator extends AbstractDebugSeqValidator {
  private static class HelperStruct {
    private Set<String> varsInAtomicBlock = new HashSet<String>();
    
    private int usedCommands = 0;
    
    public HelperStruct() {
    }
  }
  
  public static final String DUPLICATE_ELEMENT = "com.arm.cmsis.pack.dsq.DuplicateElement";
  
  public static final String SEQUENCE_UNDEFINED = "com.arm.cmsis.pack.dsq.SequenceUndefined";
  
  public static final String ASSIGNMENT_ERROR = "com.arm.cmsis.pack.dsq.AssignmentError";
  
  public static final String WRONG_TYPE = "com.arm.cmsis.pack.dsq.WrongType";
  
  public static final String SEQUENCE_CALL_IN_ATOMIC_BLOCK = "com.arm.cmsis.pack.dsq.SequenceCallInAtomicBlock";
  
  public static final String QUERY_CALL_IN_ATOMIC_BLOCK = "com.arm.cmsis.pack.dsq.QueryCallInAtomicBlock";
  
  public static final String MUST_IN_ATOMIC_BLOCK = "com.arm.cmsis.pack.dsq.MustInAtomicBlock";
  
  public static final String NESTED_COMMAND_IN_ATOMIC_BLOCK = "com.arm.cmsis.pack.dsq.NestedCommandInAtomicBlock";
  
  @Inject
  @Extension
  private DebugSeqTypeProvider _debugSeqTypeProvider;
  
  private void checkExpectedInteger(final Expression exp, final EReference reference) {
    this.checkExpectedType(exp, DebugSeqTypeProvider.intType, reference);
  }
  
  private void checkExpectedType(final Expression exp, final DebugSeqType expectedType, final EReference reference) {
    final DebugSeqType actualType = this.getTypeAndCheckNotNull(exp, reference);
    boolean _notEquals = (!Objects.equal(actualType, expectedType));
    if (_notEquals) {
      this.error(((("expected " + expectedType) + " type, but was ") + actualType), reference, DebugSeqValidator.WRONG_TYPE);
    }
  }
  
  private DebugSeqType getTypeAndCheckNotNull(final Expression exp, final EReference reference) {
    DebugSeqType _typeFor = null;
    if (exp!=null) {
      _typeFor=this._debugSeqTypeProvider.typeFor(exp);
    }
    DebugSeqType type = _typeFor;
    boolean _equals = Objects.equal(type, null);
    if (_equals) {
      this.error("null type", reference, DebugSeqValidator.WRONG_TYPE);
    }
    return type;
  }
  
  private void checkExpectedSame(final DebugSeqType left, final DebugSeqType right) {
    if ((((!Objects.equal(right, null)) && (!Objects.equal(left, null))) && (!Objects.equal(right, left)))) {
      this.error(((("expected the same type, but was " + left) + ", ") + right), 
        DebugSeqPackage.Literals.EQUALITY.getEIDAttribute(), 
        DebugSeqValidator.WRONG_TYPE);
    }
  }
  
  @Check
  public void checkNot(final Not not) {
    this.checkExpectedInteger(not.getExpression(), 
      DebugSeqPackage.Literals.NOT__EXPRESSION);
  }
  
  @Check
  public void checkAssignment(final Assignment assign) {
    Expression _left = assign.getLeft();
    boolean _not = (!(_left instanceof VariableRef));
    if (_not) {
      this.error("The left hand side of assignment expression must be a variable", 
        DebugSeqPackage.eINSTANCE.getAssignment_Left(), 
        DebugSeqValidator.ASSIGNMENT_ERROR);
      return;
    }
    Expression _left_1 = assign.getLeft();
    final String varname = ((VariableRef) _left_1).getVariable().getName();
    if (((Objects.equal(varname, "__protocol") || 
      Objects.equal(varname, "__connection")) || 
      Objects.equal(varname, "__traceout"))) {
      this.error((("Read-only variable \'" + varname) + "\' cannot be modified"), 
        DebugSeqPackage.eINSTANCE.getAssignment_Left(), 
        DebugSeqValidator.ASSIGNMENT_ERROR);
      return;
    }
    this.checkExpectedInteger(assign.getRight(), 
      DebugSeqPackage.Literals.ASSIGNMENT__RIGHT);
  }
  
  @Check
  public void checkTernary(final Ternary ternary) {
    this.checkExpectedSame(this._debugSeqTypeProvider.typeFor(ternary.getExp1()), this._debugSeqTypeProvider.typeFor(ternary.getExp2()));
  }
  
  @Check
  public void checkOr(final Or or) {
    this.checkExpectedInteger(or.getLeft(), 
      DebugSeqPackage.Literals.OR__LEFT);
    this.checkExpectedInteger(or.getRight(), 
      DebugSeqPackage.Literals.OR__RIGHT);
  }
  
  @Check
  public void checkAnd(final And and) {
    this.checkExpectedInteger(and.getLeft(), 
      DebugSeqPackage.Literals.AND__LEFT);
    this.checkExpectedInteger(and.getRight(), 
      DebugSeqPackage.Literals.AND__RIGHT);
  }
  
  @Check
  public void checkBitOr(final BitOr bitOr) {
    this.checkExpectedInteger(bitOr.getLeft(), 
      DebugSeqPackage.Literals.BIT_OR__LEFT);
    this.checkExpectedInteger(bitOr.getRight(), 
      DebugSeqPackage.Literals.BIT_OR__RIGHT);
  }
  
  @Check
  public void checkBitXor(final BitXor bitXor) {
    this.checkExpectedInteger(bitXor.getLeft(), 
      DebugSeqPackage.Literals.BIT_XOR__LEFT);
    this.checkExpectedInteger(bitXor.getRight(), 
      DebugSeqPackage.Literals.BIT_XOR__RIGHT);
  }
  
  @Check
  public void checkBitAnd(final BitAnd bitAnd) {
    this.checkExpectedInteger(bitAnd.getLeft(), 
      DebugSeqPackage.Literals.BIT_AND__LEFT);
    this.checkExpectedInteger(bitAnd.getRight(), 
      DebugSeqPackage.Literals.BIT_AND__RIGHT);
  }
  
  @Check
  public void checkShift(final Shift shift) {
    this.checkExpectedInteger(shift.getLeft(), 
      DebugSeqPackage.Literals.SHIFT__LEFT);
    this.checkExpectedInteger(shift.getRight(), 
      DebugSeqPackage.Literals.SHIFT__RIGHT);
  }
  
  @Check
  public void checkPlus(final Plus plus) {
    this.checkExpectedInteger(plus.getLeft(), 
      DebugSeqPackage.Literals.PLUS__LEFT);
    this.checkExpectedInteger(plus.getRight(), 
      DebugSeqPackage.Literals.PLUS__RIGHT);
  }
  
  @Check
  public void checkMinus(final Minus minus) {
    this.checkExpectedInteger(minus.getLeft(), 
      DebugSeqPackage.Literals.MINUS__LEFT);
    this.checkExpectedInteger(minus.getRight(), 
      DebugSeqPackage.Literals.MINUS__RIGHT);
  }
  
  @Check
  public void checkMultiply(final Mul mul) {
    this.checkExpectedInteger(mul.getLeft(), 
      DebugSeqPackage.Literals.MUL__LEFT);
    this.checkExpectedInteger(mul.getRight(), 
      DebugSeqPackage.Literals.MUL__RIGHT);
  }
  
  @Check
  public void checkDivide(final Div div) {
    this.checkExpectedInteger(div.getLeft(), 
      DebugSeqPackage.Literals.DIV__LEFT);
    this.checkExpectedInteger(div.getRight(), 
      DebugSeqPackage.Literals.DIV__RIGHT);
  }
  
  @Check
  public void checkEquality(final Equality equality) {
    final DebugSeqType leftType = this.getTypeAndCheckNotNull(equality.getLeft(), 
      DebugSeqPackage.Literals.EQUALITY__LEFT);
    final DebugSeqType rightType = this.getTypeAndCheckNotNull(equality.getRight(), 
      DebugSeqPackage.Literals.EQUALITY__RIGHT);
    this.checkExpectedSame(leftType, rightType);
  }
  
  @Check
  public void checkComparison(final Comparison comparison) {
    final DebugSeqType leftType = this.getTypeAndCheckNotNull(comparison.getLeft(), 
      DebugSeqPackage.Literals.COMPARISON__LEFT);
    final DebugSeqType rightType = this.getTypeAndCheckNotNull(comparison.getRight(), 
      DebugSeqPackage.Literals.COMPARISON__RIGHT);
    this.checkExpectedSame(leftType, rightType);
  }
  
  @Check
  public void checkQuery(final Query query) {
    this.checkExpectedInteger(query.getType(), 
      DebugSeqPackage.Literals.QUERY__TYPE);
    this.checkExpectedInteger(query.getDefault(), 
      DebugSeqPackage.Literals.QUERY__DEFAULT);
    final Block block = DebugSeqUtil.containingBlock(query);
    long _atomic = block.getAtomic();
    boolean _tripleNotEquals = (_atomic != 0);
    if (_tripleNotEquals) {
      this.error("Calling a query function in an atomic block", query, 
        null, 
        DebugSeqValidator.QUERY_CALL_IN_ATOMIC_BLOCK);
    }
  }
  
  @Check
  public void checkQueryValue(final QueryValue query) {
    this.checkExpectedInteger(query.getDefault(), 
      DebugSeqPackage.Literals.QUERY__DEFAULT);
    final Block block = DebugSeqUtil.containingBlock(query);
    long _atomic = block.getAtomic();
    boolean _tripleNotEquals = (_atomic != 0);
    if (_tripleNotEquals) {
      this.error("Calling a query function in an atomic block", query, 
        null, 
        DebugSeqValidator.QUERY_CALL_IN_ATOMIC_BLOCK);
    }
  }
  
  @Check
  public void checkSequenceCall(final SequenceCall seqCall) {
    final String name = seqCall.getSeqname();
    final Function1<Sequence, Boolean> _function = (Sequence it) -> {
      String _name = it.getName();
      return Boolean.valueOf(Objects.equal(_name, name));
    };
    final Sequence sequence = IterableExtensions.<Sequence>findFirst(DebugSeqUtil.containingSequences(seqCall).getSequences(), _function);
    if ((Objects.equal(sequence, null) && (!DebugSeqUtil.isDefaultSequence(name)))) {
      this.error((("Calling an undefined sequence \'" + name) + "\'"), 
        DebugSeqPackage.eINSTANCE.getSequenceCall_Seqname(), 
        DebugSeqValidator.SEQUENCE_UNDEFINED);
    }
    final Block block = DebugSeqUtil.containingBlock(seqCall);
    long _atomic = block.getAtomic();
    boolean _tripleNotEquals = (_atomic != 0);
    if (_tripleNotEquals) {
      this.error((("Calling sequence \'" + name) + "\' in an atomic block"), 
        DebugSeqPackage.eINSTANCE.getSequenceCall_Seqname(), 
        DebugSeqValidator.SEQUENCE_CALL_IN_ATOMIC_BLOCK);
    }
  }
  
  @Check
  public void checkRead8(final Read8 read) {
    this.checkExpectedInteger(read.getAddr(), 
      DebugSeqPackage.Literals.READ8__ADDR);
  }
  
  @Check
  public void checkRead16(final Read16 read) {
    this.checkExpectedInteger(read.getAddr(), 
      DebugSeqPackage.Literals.READ16__ADDR);
  }
  
  @Check
  public void checkRead32(final Read32 read) {
    this.checkExpectedInteger(read.getAddr(), 
      DebugSeqPackage.Literals.READ32__ADDR);
  }
  
  @Check
  public void checkRead64(final Read64 read) {
    this.checkExpectedInteger(read.getAddr(), 
      DebugSeqPackage.Literals.READ64__ADDR);
  }
  
  @Check
  public void checkReadAP(final ReadAP read) {
    this.checkExpectedInteger(read.getAddr(), 
      DebugSeqPackage.Literals.READ_AP__ADDR);
  }
  
  @Check
  public void checkReadDP(final ReadDP read) {
    this.checkExpectedInteger(read.getAddr(), 
      DebugSeqPackage.Literals.READ_DP__ADDR);
  }
  
  @Check
  public void checkWrite8(final Write8 write) {
    this.checkExpectedInteger(write.getAddr(), 
      DebugSeqPackage.Literals.WRITE8__ADDR);
    this.checkExpectedInteger(write.getVal(), 
      DebugSeqPackage.Literals.WRITE8__VAL);
  }
  
  @Check
  public void checkWrite16(final Write16 write) {
    this.checkExpectedInteger(write.getAddr(), 
      DebugSeqPackage.Literals.WRITE16__ADDR);
    this.checkExpectedInteger(write.getVal(), 
      DebugSeqPackage.Literals.WRITE16__VAL);
  }
  
  @Check
  public void checkWrite32(final Write32 write) {
    this.checkExpectedInteger(write.getAddr(), 
      DebugSeqPackage.Literals.WRITE32__ADDR);
    this.checkExpectedInteger(write.getVal(), 
      DebugSeqPackage.Literals.WRITE32__VAL);
  }
  
  @Check
  public void checkWrite64(final Write64 write) {
    this.checkExpectedInteger(write.getAddr(), 
      DebugSeqPackage.Literals.WRITE64__ADDR);
    this.checkExpectedInteger(write.getVal(), 
      DebugSeqPackage.Literals.WRITE64__VAL);
  }
  
  @Check
  public void checkWriteAP(final WriteAP write) {
    this.checkExpectedInteger(write.getAddr(), 
      DebugSeqPackage.Literals.WRITE_AP__ADDR);
    this.checkExpectedInteger(write.getVal(), 
      DebugSeqPackage.Literals.WRITE_AP__VAL);
  }
  
  @Check
  public void checkWriteDP(final WriteDP write) {
    this.checkExpectedInteger(write.getAddr(), 
      DebugSeqPackage.Literals.WRITE_DP__ADDR);
    this.checkExpectedInteger(write.getVal(), 
      DebugSeqPackage.Literals.WRITE_DP__VAL);
  }
  
  @Check
  public void checkDapDelay(final DapDelay dap) {
    this.checkExpectedInteger(dap.getDelay(), 
      DebugSeqPackage.Literals.DAP_DELAY__DELAY);
  }
  
  @Check
  public void checkDapWriteABORT(final DapWriteABORT dap) {
    this.checkExpectedInteger(dap.getValue(), 
      DebugSeqPackage.Literals.DAP_WRITE_ABORT__VALUE);
  }
  
  @Check
  public void checkDapSwjPins(final DapSwjPins dap) {
    this.checkExpectedInteger(dap.getPinout(), 
      DebugSeqPackage.Literals.DAP_SWJ_PINS__PINOUT);
    this.checkExpectedInteger(dap.getPinselect(), 
      DebugSeqPackage.Literals.DAP_SWJ_PINS__PINSELECT);
    this.checkExpectedInteger(dap.getPinwait(), 
      DebugSeqPackage.Literals.DAP_SWJ_PINS__PINWAIT);
  }
  
  @Check
  public void checkDapSwjClock(final DapSwjClock dap) {
    this.checkExpectedInteger(dap.getValue(), 
      DebugSeqPackage.Literals.DAP_SWJ_CLOCK__VALUE);
  }
  
  @Check
  public void checkDapSwjSequence(final DapSwjSequence dap) {
    this.checkExpectedInteger(dap.getCnt(), 
      DebugSeqPackage.Literals.DAP_SWJ_SEQUENCE__CNT);
    this.checkExpectedInteger(dap.getVal(), 
      DebugSeqPackage.Literals.DAP_SWJ_SEQUENCE__VAL);
    final Block block = DebugSeqUtil.containingBlock(dap);
    long _atomic = block.getAtomic();
    boolean _tripleNotEquals = (_atomic != 1);
    if (_tripleNotEquals) {
      this.error("DAP_SWJ_Sequence commands must be encapsulated in an atomic block to ensure correct execution", 
        DebugSeqPackage.eINSTANCE.getDapSwjSequence().getEIDAttribute(), 
        DebugSeqValidator.MUST_IN_ATOMIC_BLOCK);
    }
  }
  
  @Check
  public void checkDapJtagSequence(final DapJtagSequence dap) {
    this.checkExpectedInteger(dap.getCnt(), 
      DebugSeqPackage.Literals.DAP_JTAG_SEQUENCE__CNT);
    this.checkExpectedInteger(dap.getTms(), 
      DebugSeqPackage.Literals.DAP_JTAG_SEQUENCE__TMS);
    this.checkExpectedInteger(dap.getTdi(), 
      DebugSeqPackage.Literals.DAP_JTAG_SEQUENCE__TDI);
  }
  
  @Check
  public void checkNoDuplicateSequence(final Sequence seq) {
    final Function1<Sequence, Boolean> _function = (Sequence it) -> {
      return Boolean.valueOf((((!Objects.equal(it, seq)) && Objects.equal(it.getName(), seq.getName())) && Objects.equal(it.getPname(), seq.getPname())));
    };
    boolean _exists = IterableExtensions.<Sequence>exists(DebugSeqUtil.containingSequences(seq).getSequences(), _function);
    if (_exists) {
      String _name = seq.getName();
      String _plus = ("Duplicate sequence \'" + _name);
      String _plus_1 = (_plus + "\'");
      this.error(_plus_1, 
        DebugSeqPackage.eINSTANCE.getSequence_Name(), 
        DebugSeqValidator.DUPLICATE_ELEMENT);
    }
  }
  
  @Check
  public void checkNoDuplicateVariableDeclaration(final VariableDeclaration vardecl) {
    final DebugSeqModel dsm = DebugSeqUtil.containingDebugSeqModel(vardecl);
    final Function1<VariableDeclaration, Boolean> _function = (VariableDeclaration it) -> {
      return Boolean.valueOf(((!Objects.equal(it, vardecl)) && Objects.equal(it.getName(), vardecl.getName())));
    };
    final VariableDeclaration globalDeplicate = IterableExtensions.<VariableDeclaration>findFirst(Iterables.<VariableDeclaration>filter(dsm.getDebugvars().getStatements(), VariableDeclaration.class), _function);
    boolean _notEquals = (!Objects.equal(globalDeplicate, null));
    if (_notEquals) {
      String _name = vardecl.getName();
      String _plus = ("Duplicate variable declaration \'" + _name);
      String _plus_1 = (_plus + "\'");
      this.error(_plus_1, 
        DebugSeqPackage.eINSTANCE.getVariableDeclaration_Name(), 
        DebugSeqValidator.DUPLICATE_ELEMENT);
    }
    final Function1<VariableDeclaration, Boolean> _function_1 = (VariableDeclaration it) -> {
      return Boolean.valueOf((((!Objects.equal(it, vardecl)) && Objects.equal(it.getName(), vardecl.getName())) && (Objects.equal(DebugSeqUtil.containingControl(it), null) || 
        EcoreUtil.isAncestor(DebugSeqUtil.containingControl(it), DebugSeqUtil.containingControl(vardecl)))));
    };
    final VariableDeclaration localDuplicate = IterableExtensions.<VariableDeclaration>findFirst(EcoreUtil2.<VariableDeclaration>getAllContentsOfType(DebugSeqUtil.containingSequence(vardecl), VariableDeclaration.class), _function_1);
    boolean _notEquals_1 = (!Objects.equal(localDuplicate, null));
    if (_notEquals_1) {
      String _name_1 = vardecl.getName();
      String _plus_2 = ("Duplicate variable declaration \'" + _name_1);
      String _plus_3 = (_plus_2 + "\'");
      this.error(_plus_3, 
        DebugSeqPackage.eINSTANCE.getVariableDeclaration_Name(), 
        DebugSeqValidator.DUPLICATE_ELEMENT);
    }
  }
  
  @Check
  public void checkAtomicBlock(final Block block) {
    long _atomic = block.getAtomic();
    boolean _tripleEquals = (_atomic == 1);
    if (_tripleEquals) {
      final DebugSeqValidator.HelperStruct helper = new DebugSeqValidator.HelperStruct();
      boolean _checkStatement = this.checkStatement(block, helper);
      boolean _not = (!_checkStatement);
      if (_not) {
        this.error("Nested command execution is not allowed in an atomic block", 
          DebugSeqPackage.eINSTANCE.getBlock().getEIDAttribute(), 
          DebugSeqValidator.NESTED_COMMAND_IN_ATOMIC_BLOCK);
      }
    }
  }
  
  private boolean checkStatement(final EObject parent, final DebugSeqValidator.HelperStruct helper) {
    final Iterable<Statement> statements = Iterables.<Statement>filter(parent.eContents(), Statement.class);
    if (((statements == null) || IterableExtensions.isEmpty(statements))) {
      return true;
    }
    final Function1<Statement, Boolean> _function = (Statement it) -> {
      boolean _switchResult = false;
      boolean _matched = false;
      if (it instanceof VariableDeclaration) {
        _matched=true;
        final int usedCommands = helper.usedCommands;
        boolean _checkStatement = this.checkStatement(it, helper);
        boolean _not = (!_checkStatement);
        if (_not) {
          return Boolean.valueOf(false);
        }
        if ((usedCommands < helper.usedCommands)) {
          helper.varsInAtomicBlock.add(((VariableDeclaration)it).getName());
        }
        return Boolean.valueOf(true);
      }
      if (!_matched) {
        if (it instanceof VariableRef) {
          _matched=true;
          if (((((VariableRef)it).eContainer() instanceof Assignment) && (it == ((Assignment) ((VariableRef)it).eContainer()).getLeft()))) {
            return Boolean.valueOf(true);
          }
          final String varName = ((VariableRef)it).getVariable().getName();
          boolean _contains = helper.varsInAtomicBlock.contains(varName);
          if (_contains) {
            helper.usedCommands++;
          }
          return Boolean.valueOf(true);
        }
      }
      if (!_matched) {
        if (it instanceof Assignment) {
          _matched=true;
          Expression _left = ((Assignment)it).getLeft();
          final String varName = ((VariableRef) _left).getVariable().getName();
          final int usedCommands = helper.usedCommands;
          boolean _checkStatement = this.checkStatement(it, helper);
          boolean _not = (!_checkStatement);
          if (_not) {
            return Boolean.valueOf(false);
          }
          if ((usedCommands < helper.usedCommands)) {
            helper.varsInAtomicBlock.add(varName);
          } else {
            helper.varsInAtomicBlock.remove(varName);
          }
          return Boolean.valueOf(true);
        }
      }
      if (!_matched) {
        if (it instanceof LoadDebugInfo) {
          _matched=true;
        }
        if (!_matched) {
          if (it instanceof Message) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof Read8) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof Read16) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof Read32) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof Read64) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof ReadAP) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof ReadDP) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof Write8) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof Write16) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof Write32) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof Write64) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof WriteAP) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof WriteDP) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof DapDelay) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof DapWriteABORT) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof DapSwjPins) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof DapSwjClock) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof DapSwjSequence) {
            _matched=true;
          }
        }
        if (!_matched) {
          if (it instanceof DapJtagSequence) {
            _matched=true;
          }
        }
        if (_matched) {
          _switchResult = this.checkCommand(((Expression)it), helper);
        }
      }
      if (!_matched) {
        return Boolean.valueOf(this.checkStatement(it, helper));
      }
      return Boolean.valueOf(_switchResult);
    };
    final Function1<Boolean, Boolean> _function_1 = (Boolean it) -> {
      return Boolean.valueOf((it == Boolean.valueOf(false)));
    };
    final Boolean check = IterableExtensions.<Boolean>findFirst(IterableExtensions.<Statement, Boolean>map(statements, _function), _function_1);
    boolean _xifexpression = false;
    if ((check == null)) {
      _xifexpression = true;
    } else {
      _xifexpression = false;
    }
    return _xifexpression;
  }
  
  private boolean checkCommand(final Expression command, final DebugSeqValidator.HelperStruct helper) {
    final int usedCommands = helper.usedCommands;
    final boolean check = this.checkStatement(command, helper);
    if ((usedCommands < helper.usedCommands)) {
      return false;
    }
    helper.usedCommands++;
    return check;
  }
}
