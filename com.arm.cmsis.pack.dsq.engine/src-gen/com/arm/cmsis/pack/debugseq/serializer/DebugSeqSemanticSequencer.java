/*
 * generated by Xtext 2.10.0
 */
package com.arm.cmsis.pack.debugseq.serializer;

import com.arm.cmsis.pack.debugseq.debugSeq.And;
import com.arm.cmsis.pack.debugseq.debugSeq.Assignment;
import com.arm.cmsis.pack.debugseq.debugSeq.BitAnd;
import com.arm.cmsis.pack.debugseq.debugSeq.BitNot;
import com.arm.cmsis.pack.debugseq.debugSeq.BitOr;
import com.arm.cmsis.pack.debugseq.debugSeq.BitXor;
import com.arm.cmsis.pack.debugseq.debugSeq.Block;
import com.arm.cmsis.pack.debugseq.debugSeq.Comparison;
import com.arm.cmsis.pack.debugseq.debugSeq.Control;
import com.arm.cmsis.pack.debugseq.debugSeq.DapDelay;
import com.arm.cmsis.pack.debugseq.debugSeq.DapJtagSequence;
import com.arm.cmsis.pack.debugseq.debugSeq.DapSwjClock;
import com.arm.cmsis.pack.debugseq.debugSeq.DapSwjPins;
import com.arm.cmsis.pack.debugseq.debugSeq.DapSwjSequence;
import com.arm.cmsis.pack.debugseq.debugSeq.DapWriteABORT;
import com.arm.cmsis.pack.debugseq.debugSeq.DebugSeqModel;
import com.arm.cmsis.pack.debugseq.debugSeq.DebugSeqPackage;
import com.arm.cmsis.pack.debugseq.debugSeq.DebugVars;
import com.arm.cmsis.pack.debugseq.debugSeq.Div;
import com.arm.cmsis.pack.debugseq.debugSeq.Equality;
import com.arm.cmsis.pack.debugseq.debugSeq.IntConstant;
import com.arm.cmsis.pack.debugseq.debugSeq.LoadDebugInfo;
import com.arm.cmsis.pack.debugseq.debugSeq.Message;
import com.arm.cmsis.pack.debugseq.debugSeq.Minus;
import com.arm.cmsis.pack.debugseq.debugSeq.Mul;
import com.arm.cmsis.pack.debugseq.debugSeq.Not;
import com.arm.cmsis.pack.debugseq.debugSeq.Or;
import com.arm.cmsis.pack.debugseq.debugSeq.Plus;
import com.arm.cmsis.pack.debugseq.debugSeq.Query;
import com.arm.cmsis.pack.debugseq.debugSeq.QueryValue;
import com.arm.cmsis.pack.debugseq.debugSeq.Read16;
import com.arm.cmsis.pack.debugseq.debugSeq.Read32;
import com.arm.cmsis.pack.debugseq.debugSeq.Read64;
import com.arm.cmsis.pack.debugseq.debugSeq.Read8;
import com.arm.cmsis.pack.debugseq.debugSeq.ReadAP;
import com.arm.cmsis.pack.debugseq.debugSeq.ReadDP;
import com.arm.cmsis.pack.debugseq.debugSeq.Rem;
import com.arm.cmsis.pack.debugseq.debugSeq.Sequence;
import com.arm.cmsis.pack.debugseq.debugSeq.SequenceCall;
import com.arm.cmsis.pack.debugseq.debugSeq.Sequences;
import com.arm.cmsis.pack.debugseq.debugSeq.Shift;
import com.arm.cmsis.pack.debugseq.debugSeq.StringConstant;
import com.arm.cmsis.pack.debugseq.debugSeq.Ternary;
import com.arm.cmsis.pack.debugseq.debugSeq.VariableDeclaration;
import com.arm.cmsis.pack.debugseq.debugSeq.VariableRef;
import com.arm.cmsis.pack.debugseq.debugSeq.Write16;
import com.arm.cmsis.pack.debugseq.debugSeq.Write32;
import com.arm.cmsis.pack.debugseq.debugSeq.Write64;
import com.arm.cmsis.pack.debugseq.debugSeq.Write8;
import com.arm.cmsis.pack.debugseq.debugSeq.WriteAP;
import com.arm.cmsis.pack.debugseq.debugSeq.WriteDP;
import com.arm.cmsis.pack.debugseq.services.DebugSeqGrammarAccess;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class DebugSeqSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DebugSeqGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DebugSeqPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DebugSeqPackage.AND:
				sequence_And(context, (And) semanticObject); 
				return; 
			case DebugSeqPackage.ASSIGNMENT:
				sequence_Assignment(context, (Assignment) semanticObject); 
				return; 
			case DebugSeqPackage.BIT_AND:
				sequence_BitAnd(context, (BitAnd) semanticObject); 
				return; 
			case DebugSeqPackage.BIT_NOT:
				sequence_Primary(context, (BitNot) semanticObject); 
				return; 
			case DebugSeqPackage.BIT_OR:
				sequence_BitOr(context, (BitOr) semanticObject); 
				return; 
			case DebugSeqPackage.BIT_XOR:
				sequence_BitXor(context, (BitXor) semanticObject); 
				return; 
			case DebugSeqPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case DebugSeqPackage.COMPARISON:
				sequence_Comparison(context, (Comparison) semanticObject); 
				return; 
			case DebugSeqPackage.CONTROL:
				sequence_Control(context, (Control) semanticObject); 
				return; 
			case DebugSeqPackage.DAP_DELAY:
				sequence_FunctionCall(context, (DapDelay) semanticObject); 
				return; 
			case DebugSeqPackage.DAP_JTAG_SEQUENCE:
				sequence_FunctionCall(context, (DapJtagSequence) semanticObject); 
				return; 
			case DebugSeqPackage.DAP_SWJ_CLOCK:
				sequence_FunctionCall(context, (DapSwjClock) semanticObject); 
				return; 
			case DebugSeqPackage.DAP_SWJ_PINS:
				sequence_FunctionCall(context, (DapSwjPins) semanticObject); 
				return; 
			case DebugSeqPackage.DAP_SWJ_SEQUENCE:
				sequence_FunctionCall(context, (DapSwjSequence) semanticObject); 
				return; 
			case DebugSeqPackage.DAP_WRITE_ABORT:
				sequence_FunctionCall(context, (DapWriteABORT) semanticObject); 
				return; 
			case DebugSeqPackage.DEBUG_SEQ_MODEL:
				sequence_DebugSeqModel(context, (DebugSeqModel) semanticObject); 
				return; 
			case DebugSeqPackage.DEBUG_VARS:
				sequence_DebugVars(context, (DebugVars) semanticObject); 
				return; 
			case DebugSeqPackage.DIV:
				sequence_MulOrDiv(context, (Div) semanticObject); 
				return; 
			case DebugSeqPackage.EQUALITY:
				sequence_Equality(context, (Equality) semanticObject); 
				return; 
			case DebugSeqPackage.INT_CONSTANT:
				sequence_Atomic(context, (IntConstant) semanticObject); 
				return; 
			case DebugSeqPackage.LOAD_DEBUG_INFO:
				sequence_FunctionCall(context, (LoadDebugInfo) semanticObject); 
				return; 
			case DebugSeqPackage.MESSAGE:
				sequence_FunctionCall(context, (Message) semanticObject); 
				return; 
			case DebugSeqPackage.MINUS:
				sequence_PlusOrMinus(context, (Minus) semanticObject); 
				return; 
			case DebugSeqPackage.MUL:
				sequence_MulOrDiv(context, (Mul) semanticObject); 
				return; 
			case DebugSeqPackage.NOT:
				sequence_Primary(context, (Not) semanticObject); 
				return; 
			case DebugSeqPackage.OR:
				sequence_Or(context, (Or) semanticObject); 
				return; 
			case DebugSeqPackage.PLUS:
				sequence_PlusOrMinus(context, (Plus) semanticObject); 
				return; 
			case DebugSeqPackage.QUERY:
				sequence_FunctionCall(context, (Query) semanticObject); 
				return; 
			case DebugSeqPackage.QUERY_VALUE:
				sequence_FunctionCall(context, (QueryValue) semanticObject); 
				return; 
			case DebugSeqPackage.READ16:
				sequence_FunctionCall(context, (Read16) semanticObject); 
				return; 
			case DebugSeqPackage.READ32:
				sequence_FunctionCall(context, (Read32) semanticObject); 
				return; 
			case DebugSeqPackage.READ64:
				sequence_FunctionCall(context, (Read64) semanticObject); 
				return; 
			case DebugSeqPackage.READ8:
				sequence_FunctionCall(context, (Read8) semanticObject); 
				return; 
			case DebugSeqPackage.READ_AP:
				sequence_FunctionCall(context, (ReadAP) semanticObject); 
				return; 
			case DebugSeqPackage.READ_DP:
				sequence_FunctionCall(context, (ReadDP) semanticObject); 
				return; 
			case DebugSeqPackage.REM:
				sequence_MulOrDiv(context, (Rem) semanticObject); 
				return; 
			case DebugSeqPackage.SEQUENCE:
				sequence_Sequence(context, (Sequence) semanticObject); 
				return; 
			case DebugSeqPackage.SEQUENCE_CALL:
				sequence_FunctionCall(context, (SequenceCall) semanticObject); 
				return; 
			case DebugSeqPackage.SEQUENCES:
				sequence_Sequences(context, (Sequences) semanticObject); 
				return; 
			case DebugSeqPackage.SHIFT:
				sequence_Shift(context, (Shift) semanticObject); 
				return; 
			case DebugSeqPackage.STRING_CONSTANT:
				sequence_Atomic(context, (StringConstant) semanticObject); 
				return; 
			case DebugSeqPackage.TERNARY:
				sequence_Ternary(context, (Ternary) semanticObject); 
				return; 
			case DebugSeqPackage.VARIABLE_DECLARATION:
				sequence_VariableDeclaration(context, (VariableDeclaration) semanticObject); 
				return; 
			case DebugSeqPackage.VARIABLE_REF:
				sequence_Atomic(context, (VariableRef) semanticObject); 
				return; 
			case DebugSeqPackage.WRITE16:
				sequence_FunctionCall(context, (Write16) semanticObject); 
				return; 
			case DebugSeqPackage.WRITE32:
				sequence_FunctionCall(context, (Write32) semanticObject); 
				return; 
			case DebugSeqPackage.WRITE64:
				sequence_FunctionCall(context, (Write64) semanticObject); 
				return; 
			case DebugSeqPackage.WRITE8:
				sequence_FunctionCall(context, (Write8) semanticObject); 
				return; 
			case DebugSeqPackage.WRITE_AP:
				sequence_FunctionCall(context, (WriteAP) semanticObject); 
				return; 
			case DebugSeqPackage.WRITE_DP:
				sequence_FunctionCall(context, (WriteDP) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Statement returns And
	 *     Expression returns And
	 *     Assignment returns And
	 *     Assignment.Assignment_1_0 returns And
	 *     Ternary returns And
	 *     Ternary.Ternary_1_0 returns And
	 *     Or returns And
	 *     Or.Or_1_0 returns And
	 *     And returns And
	 *     And.And_1_0 returns And
	 *     BitOr returns And
	 *     BitOr.BitOr_1_0 returns And
	 *     BitXor returns And
	 *     BitXor.BitXor_1_0 returns And
	 *     BitAnd returns And
	 *     BitAnd.BitAnd_1_0 returns And
	 *     Equality returns And
	 *     Equality.Equality_1_0 returns And
	 *     Comparison returns And
	 *     Comparison.Comparison_1_0 returns And
	 *     Shift returns And
	 *     Shift.Shift_1_0 returns And
	 *     PlusOrMinus returns And
	 *     PlusOrMinus.Plus_1_0_0_0 returns And
	 *     PlusOrMinus.Minus_1_0_1_0 returns And
	 *     MulOrDiv returns And
	 *     MulOrDiv.Mul_1_0_0_0 returns And
	 *     MulOrDiv.Div_1_0_1_0 returns And
	 *     MulOrDiv.Rem_1_0_2_0 returns And
	 *     Primary returns And
	 *     Parameter returns And
	 *
	 * Constraint:
	 *     (left=And_And_1_0 right=BitOr)
	 */
	protected void sequence_And(ISerializationContext context, And semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndAccess().getAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndAccess().getRightBitOrParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Assignment
	 *     Expression returns Assignment
	 *     Assignment returns Assignment
	 *     Assignment.Assignment_1_0 returns Assignment
	 *     Ternary returns Assignment
	 *     Ternary.Ternary_1_0 returns Assignment
	 *     Or returns Assignment
	 *     Or.Or_1_0 returns Assignment
	 *     And returns Assignment
	 *     And.And_1_0 returns Assignment
	 *     BitOr returns Assignment
	 *     BitOr.BitOr_1_0 returns Assignment
	 *     BitXor returns Assignment
	 *     BitXor.BitXor_1_0 returns Assignment
	 *     BitAnd returns Assignment
	 *     BitAnd.BitAnd_1_0 returns Assignment
	 *     Equality returns Assignment
	 *     Equality.Equality_1_0 returns Assignment
	 *     Comparison returns Assignment
	 *     Comparison.Comparison_1_0 returns Assignment
	 *     Shift returns Assignment
	 *     Shift.Shift_1_0 returns Assignment
	 *     PlusOrMinus returns Assignment
	 *     PlusOrMinus.Plus_1_0_0_0 returns Assignment
	 *     PlusOrMinus.Minus_1_0_1_0 returns Assignment
	 *     MulOrDiv returns Assignment
	 *     MulOrDiv.Mul_1_0_0_0 returns Assignment
	 *     MulOrDiv.Div_1_0_1_0 returns Assignment
	 *     MulOrDiv.Rem_1_0_2_0 returns Assignment
	 *     Primary returns Assignment
	 *     Parameter returns Assignment
	 *
	 * Constraint:
	 *     (
	 *         left=Assignment_Assignment_1_0 
	 *         (
	 *             op='=' | 
	 *             op='+=' | 
	 *             op='-=' | 
	 *             op='*=' | 
	 *             op='/=' | 
	 *             op='%=' | 
	 *             op='&lt;&lt;=' | 
	 *             op='&gt;&gt;=' | 
	 *             op='&amp;=' | 
	 *             op='^=' | 
	 *             op='|='
	 *         ) 
	 *         right=Expression
	 *     )
	 */
	protected void sequence_Assignment(ISerializationContext context, Assignment semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns IntConstant
	 *     Expression returns IntConstant
	 *     Assignment returns IntConstant
	 *     Assignment.Assignment_1_0 returns IntConstant
	 *     Ternary returns IntConstant
	 *     Ternary.Ternary_1_0 returns IntConstant
	 *     Or returns IntConstant
	 *     Or.Or_1_0 returns IntConstant
	 *     And returns IntConstant
	 *     And.And_1_0 returns IntConstant
	 *     BitOr returns IntConstant
	 *     BitOr.BitOr_1_0 returns IntConstant
	 *     BitXor returns IntConstant
	 *     BitXor.BitXor_1_0 returns IntConstant
	 *     BitAnd returns IntConstant
	 *     BitAnd.BitAnd_1_0 returns IntConstant
	 *     Equality returns IntConstant
	 *     Equality.Equality_1_0 returns IntConstant
	 *     Comparison returns IntConstant
	 *     Comparison.Comparison_1_0 returns IntConstant
	 *     Shift returns IntConstant
	 *     Shift.Shift_1_0 returns IntConstant
	 *     PlusOrMinus returns IntConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns IntConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns IntConstant
	 *     MulOrDiv returns IntConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns IntConstant
	 *     MulOrDiv.Div_1_0_1_0 returns IntConstant
	 *     MulOrDiv.Rem_1_0_2_0 returns IntConstant
	 *     Primary returns IntConstant
	 *     Parameter returns IntConstant
	 *     Atomic returns IntConstant
	 *
	 * Constraint:
	 *     (value=DEC | value=HEX)
	 */
	protected void sequence_Atomic(ISerializationContext context, IntConstant semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns StringConstant
	 *     Expression returns StringConstant
	 *     Assignment returns StringConstant
	 *     Assignment.Assignment_1_0 returns StringConstant
	 *     Ternary returns StringConstant
	 *     Ternary.Ternary_1_0 returns StringConstant
	 *     Or returns StringConstant
	 *     Or.Or_1_0 returns StringConstant
	 *     And returns StringConstant
	 *     And.And_1_0 returns StringConstant
	 *     BitOr returns StringConstant
	 *     BitOr.BitOr_1_0 returns StringConstant
	 *     BitXor returns StringConstant
	 *     BitXor.BitXor_1_0 returns StringConstant
	 *     BitAnd returns StringConstant
	 *     BitAnd.BitAnd_1_0 returns StringConstant
	 *     Equality returns StringConstant
	 *     Equality.Equality_1_0 returns StringConstant
	 *     Comparison returns StringConstant
	 *     Comparison.Comparison_1_0 returns StringConstant
	 *     Shift returns StringConstant
	 *     Shift.Shift_1_0 returns StringConstant
	 *     PlusOrMinus returns StringConstant
	 *     PlusOrMinus.Plus_1_0_0_0 returns StringConstant
	 *     PlusOrMinus.Minus_1_0_1_0 returns StringConstant
	 *     MulOrDiv returns StringConstant
	 *     MulOrDiv.Mul_1_0_0_0 returns StringConstant
	 *     MulOrDiv.Div_1_0_1_0 returns StringConstant
	 *     MulOrDiv.Rem_1_0_2_0 returns StringConstant
	 *     Primary returns StringConstant
	 *     Parameter returns StringConstant
	 *     Atomic returns StringConstant
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Atomic(ISerializationContext context, StringConstant semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.STRING_CONSTANT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.STRING_CONSTANT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getValueSTRINGTerminalRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VariableRef
	 *     Expression returns VariableRef
	 *     Assignment returns VariableRef
	 *     Assignment.Assignment_1_0 returns VariableRef
	 *     Ternary returns VariableRef
	 *     Ternary.Ternary_1_0 returns VariableRef
	 *     Or returns VariableRef
	 *     Or.Or_1_0 returns VariableRef
	 *     And returns VariableRef
	 *     And.And_1_0 returns VariableRef
	 *     BitOr returns VariableRef
	 *     BitOr.BitOr_1_0 returns VariableRef
	 *     BitXor returns VariableRef
	 *     BitXor.BitXor_1_0 returns VariableRef
	 *     BitAnd returns VariableRef
	 *     BitAnd.BitAnd_1_0 returns VariableRef
	 *     Equality returns VariableRef
	 *     Equality.Equality_1_0 returns VariableRef
	 *     Comparison returns VariableRef
	 *     Comparison.Comparison_1_0 returns VariableRef
	 *     Shift returns VariableRef
	 *     Shift.Shift_1_0 returns VariableRef
	 *     PlusOrMinus returns VariableRef
	 *     PlusOrMinus.Plus_1_0_0_0 returns VariableRef
	 *     PlusOrMinus.Minus_1_0_1_0 returns VariableRef
	 *     MulOrDiv returns VariableRef
	 *     MulOrDiv.Mul_1_0_0_0 returns VariableRef
	 *     MulOrDiv.Div_1_0_1_0 returns VariableRef
	 *     MulOrDiv.Rem_1_0_2_0 returns VariableRef
	 *     Primary returns VariableRef
	 *     Parameter returns VariableRef
	 *     Atomic returns VariableRef
	 *
	 * Constraint:
	 *     variable=[VariableDeclaration|ID]
	 */
	protected void sequence_Atomic(ISerializationContext context, VariableRef semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.VARIABLE_REF__VARIABLE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.VARIABLE_REF__VARIABLE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAtomicAccess().getVariableVariableDeclarationIDTerminalRuleCall_2_1_0_1(), semanticObject.getVariable());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BitAnd
	 *     Expression returns BitAnd
	 *     Assignment returns BitAnd
	 *     Assignment.Assignment_1_0 returns BitAnd
	 *     Ternary returns BitAnd
	 *     Ternary.Ternary_1_0 returns BitAnd
	 *     Or returns BitAnd
	 *     Or.Or_1_0 returns BitAnd
	 *     And returns BitAnd
	 *     And.And_1_0 returns BitAnd
	 *     BitOr returns BitAnd
	 *     BitOr.BitOr_1_0 returns BitAnd
	 *     BitXor returns BitAnd
	 *     BitXor.BitXor_1_0 returns BitAnd
	 *     BitAnd returns BitAnd
	 *     BitAnd.BitAnd_1_0 returns BitAnd
	 *     Equality returns BitAnd
	 *     Equality.Equality_1_0 returns BitAnd
	 *     Comparison returns BitAnd
	 *     Comparison.Comparison_1_0 returns BitAnd
	 *     Shift returns BitAnd
	 *     Shift.Shift_1_0 returns BitAnd
	 *     PlusOrMinus returns BitAnd
	 *     PlusOrMinus.Plus_1_0_0_0 returns BitAnd
	 *     PlusOrMinus.Minus_1_0_1_0 returns BitAnd
	 *     MulOrDiv returns BitAnd
	 *     MulOrDiv.Mul_1_0_0_0 returns BitAnd
	 *     MulOrDiv.Div_1_0_1_0 returns BitAnd
	 *     MulOrDiv.Rem_1_0_2_0 returns BitAnd
	 *     Primary returns BitAnd
	 *     Parameter returns BitAnd
	 *
	 * Constraint:
	 *     (left=BitAnd_BitAnd_1_0 right=Equality)
	 */
	protected void sequence_BitAnd(ISerializationContext context, BitAnd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.BIT_AND__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.BIT_AND__LEFT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.BIT_AND__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.BIT_AND__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitAndAccess().getBitAndLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitAndAccess().getRightEqualityParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BitOr
	 *     Expression returns BitOr
	 *     Assignment returns BitOr
	 *     Assignment.Assignment_1_0 returns BitOr
	 *     Ternary returns BitOr
	 *     Ternary.Ternary_1_0 returns BitOr
	 *     Or returns BitOr
	 *     Or.Or_1_0 returns BitOr
	 *     And returns BitOr
	 *     And.And_1_0 returns BitOr
	 *     BitOr returns BitOr
	 *     BitOr.BitOr_1_0 returns BitOr
	 *     BitXor returns BitOr
	 *     BitXor.BitXor_1_0 returns BitOr
	 *     BitAnd returns BitOr
	 *     BitAnd.BitAnd_1_0 returns BitOr
	 *     Equality returns BitOr
	 *     Equality.Equality_1_0 returns BitOr
	 *     Comparison returns BitOr
	 *     Comparison.Comparison_1_0 returns BitOr
	 *     Shift returns BitOr
	 *     Shift.Shift_1_0 returns BitOr
	 *     PlusOrMinus returns BitOr
	 *     PlusOrMinus.Plus_1_0_0_0 returns BitOr
	 *     PlusOrMinus.Minus_1_0_1_0 returns BitOr
	 *     MulOrDiv returns BitOr
	 *     MulOrDiv.Mul_1_0_0_0 returns BitOr
	 *     MulOrDiv.Div_1_0_1_0 returns BitOr
	 *     MulOrDiv.Rem_1_0_2_0 returns BitOr
	 *     Primary returns BitOr
	 *     Parameter returns BitOr
	 *
	 * Constraint:
	 *     (left=BitOr_BitOr_1_0 right=BitXor)
	 */
	protected void sequence_BitOr(ISerializationContext context, BitOr semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.BIT_OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.BIT_OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.BIT_OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.BIT_OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitOrAccess().getBitOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitOrAccess().getRightBitXorParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BitXor
	 *     Expression returns BitXor
	 *     Assignment returns BitXor
	 *     Assignment.Assignment_1_0 returns BitXor
	 *     Ternary returns BitXor
	 *     Ternary.Ternary_1_0 returns BitXor
	 *     Or returns BitXor
	 *     Or.Or_1_0 returns BitXor
	 *     And returns BitXor
	 *     And.And_1_0 returns BitXor
	 *     BitOr returns BitXor
	 *     BitOr.BitOr_1_0 returns BitXor
	 *     BitXor returns BitXor
	 *     BitXor.BitXor_1_0 returns BitXor
	 *     BitAnd returns BitXor
	 *     BitAnd.BitAnd_1_0 returns BitXor
	 *     Equality returns BitXor
	 *     Equality.Equality_1_0 returns BitXor
	 *     Comparison returns BitXor
	 *     Comparison.Comparison_1_0 returns BitXor
	 *     Shift returns BitXor
	 *     Shift.Shift_1_0 returns BitXor
	 *     PlusOrMinus returns BitXor
	 *     PlusOrMinus.Plus_1_0_0_0 returns BitXor
	 *     PlusOrMinus.Minus_1_0_1_0 returns BitXor
	 *     MulOrDiv returns BitXor
	 *     MulOrDiv.Mul_1_0_0_0 returns BitXor
	 *     MulOrDiv.Div_1_0_1_0 returns BitXor
	 *     MulOrDiv.Rem_1_0_2_0 returns BitXor
	 *     Primary returns BitXor
	 *     Parameter returns BitXor
	 *
	 * Constraint:
	 *     (left=BitXor_BitXor_1_0 right=BitAnd)
	 */
	protected void sequence_BitXor(ISerializationContext context, BitXor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.BIT_XOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.BIT_XOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.BIT_XOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.BIT_XOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBitXorAccess().getBitXorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getBitXorAccess().getRightBitAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     CodeBlock returns Block
	 *     Block returns Block
	 *
	 * Constraint:
	 *     ((atomic=DEC | info=STRING)* statements+=Statement*)
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Comparison
	 *     Expression returns Comparison
	 *     Assignment returns Comparison
	 *     Assignment.Assignment_1_0 returns Comparison
	 *     Ternary returns Comparison
	 *     Ternary.Ternary_1_0 returns Comparison
	 *     Or returns Comparison
	 *     Or.Or_1_0 returns Comparison
	 *     And returns Comparison
	 *     And.And_1_0 returns Comparison
	 *     BitOr returns Comparison
	 *     BitOr.BitOr_1_0 returns Comparison
	 *     BitXor returns Comparison
	 *     BitXor.BitXor_1_0 returns Comparison
	 *     BitAnd returns Comparison
	 *     BitAnd.BitAnd_1_0 returns Comparison
	 *     Equality returns Comparison
	 *     Equality.Equality_1_0 returns Comparison
	 *     Comparison returns Comparison
	 *     Comparison.Comparison_1_0 returns Comparison
	 *     Shift returns Comparison
	 *     Shift.Shift_1_0 returns Comparison
	 *     PlusOrMinus returns Comparison
	 *     PlusOrMinus.Plus_1_0_0_0 returns Comparison
	 *     PlusOrMinus.Minus_1_0_1_0 returns Comparison
	 *     MulOrDiv returns Comparison
	 *     MulOrDiv.Mul_1_0_0_0 returns Comparison
	 *     MulOrDiv.Div_1_0_1_0 returns Comparison
	 *     MulOrDiv.Rem_1_0_2_0 returns Comparison
	 *     Primary returns Comparison
	 *     Parameter returns Comparison
	 *
	 * Constraint:
	 *     (left=Comparison_Comparison_1_0 (op='&gt;=' | op='&lt;=' | op='&gt;' | op='&lt;') right=Shift)
	 */
	protected void sequence_Comparison(ISerializationContext context, Comparison semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CodeBlock returns Control
	 *     Control returns Control
	 *
	 * Constraint:
	 *     ((if=Expression | while=Expression | timeout=DEC | info=STRING)* codeblocks+=CodeBlock*)
	 */
	protected void sequence_Control(ISerializationContext context, Control semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DebugSeqModel returns DebugSeqModel
	 *
	 * Constraint:
	 *     (debugvars=DebugVars sequences=Sequences?)
	 */
	protected void sequence_DebugSeqModel(ISerializationContext context, DebugSeqModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DebugVars returns DebugVars
	 *
	 * Constraint:
	 *     ((configfile=STRING | version=STRING | pname=STRING)* statements+=Statement*)
	 */
	protected void sequence_DebugVars(ISerializationContext context, DebugVars semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Equality
	 *     Expression returns Equality
	 *     Assignment returns Equality
	 *     Assignment.Assignment_1_0 returns Equality
	 *     Ternary returns Equality
	 *     Ternary.Ternary_1_0 returns Equality
	 *     Or returns Equality
	 *     Or.Or_1_0 returns Equality
	 *     And returns Equality
	 *     And.And_1_0 returns Equality
	 *     BitOr returns Equality
	 *     BitOr.BitOr_1_0 returns Equality
	 *     BitXor returns Equality
	 *     BitXor.BitXor_1_0 returns Equality
	 *     BitAnd returns Equality
	 *     BitAnd.BitAnd_1_0 returns Equality
	 *     Equality returns Equality
	 *     Equality.Equality_1_0 returns Equality
	 *     Comparison returns Equality
	 *     Comparison.Comparison_1_0 returns Equality
	 *     Shift returns Equality
	 *     Shift.Shift_1_0 returns Equality
	 *     PlusOrMinus returns Equality
	 *     PlusOrMinus.Plus_1_0_0_0 returns Equality
	 *     PlusOrMinus.Minus_1_0_1_0 returns Equality
	 *     MulOrDiv returns Equality
	 *     MulOrDiv.Mul_1_0_0_0 returns Equality
	 *     MulOrDiv.Div_1_0_1_0 returns Equality
	 *     MulOrDiv.Rem_1_0_2_0 returns Equality
	 *     Primary returns Equality
	 *     Parameter returns Equality
	 *
	 * Constraint:
	 *     (left=Equality_Equality_1_0 (op='==' | op='!=') right=Comparison)
	 */
	protected void sequence_Equality(ISerializationContext context, Equality semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DapDelay
	 *     Expression returns DapDelay
	 *     Assignment returns DapDelay
	 *     Assignment.Assignment_1_0 returns DapDelay
	 *     Ternary returns DapDelay
	 *     Ternary.Ternary_1_0 returns DapDelay
	 *     Or returns DapDelay
	 *     Or.Or_1_0 returns DapDelay
	 *     And returns DapDelay
	 *     And.And_1_0 returns DapDelay
	 *     BitOr returns DapDelay
	 *     BitOr.BitOr_1_0 returns DapDelay
	 *     BitXor returns DapDelay
	 *     BitXor.BitXor_1_0 returns DapDelay
	 *     BitAnd returns DapDelay
	 *     BitAnd.BitAnd_1_0 returns DapDelay
	 *     Equality returns DapDelay
	 *     Equality.Equality_1_0 returns DapDelay
	 *     Comparison returns DapDelay
	 *     Comparison.Comparison_1_0 returns DapDelay
	 *     Shift returns DapDelay
	 *     Shift.Shift_1_0 returns DapDelay
	 *     PlusOrMinus returns DapDelay
	 *     PlusOrMinus.Plus_1_0_0_0 returns DapDelay
	 *     PlusOrMinus.Minus_1_0_1_0 returns DapDelay
	 *     MulOrDiv returns DapDelay
	 *     MulOrDiv.Mul_1_0_0_0 returns DapDelay
	 *     MulOrDiv.Div_1_0_1_0 returns DapDelay
	 *     MulOrDiv.Rem_1_0_2_0 returns DapDelay
	 *     Primary returns DapDelay
	 *     Parameter returns DapDelay
	 *     FunctionCall returns DapDelay
	 *
	 * Constraint:
	 *     delay=Expression
	 */
	protected void sequence_FunctionCall(ISerializationContext context, DapDelay semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DAP_DELAY__DELAY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DAP_DELAY__DELAY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getDelayExpressionParserRuleCall_17_3_0(), semanticObject.getDelay());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DapJtagSequence
	 *     Expression returns DapJtagSequence
	 *     Assignment returns DapJtagSequence
	 *     Assignment.Assignment_1_0 returns DapJtagSequence
	 *     Ternary returns DapJtagSequence
	 *     Ternary.Ternary_1_0 returns DapJtagSequence
	 *     Or returns DapJtagSequence
	 *     Or.Or_1_0 returns DapJtagSequence
	 *     And returns DapJtagSequence
	 *     And.And_1_0 returns DapJtagSequence
	 *     BitOr returns DapJtagSequence
	 *     BitOr.BitOr_1_0 returns DapJtagSequence
	 *     BitXor returns DapJtagSequence
	 *     BitXor.BitXor_1_0 returns DapJtagSequence
	 *     BitAnd returns DapJtagSequence
	 *     BitAnd.BitAnd_1_0 returns DapJtagSequence
	 *     Equality returns DapJtagSequence
	 *     Equality.Equality_1_0 returns DapJtagSequence
	 *     Comparison returns DapJtagSequence
	 *     Comparison.Comparison_1_0 returns DapJtagSequence
	 *     Shift returns DapJtagSequence
	 *     Shift.Shift_1_0 returns DapJtagSequence
	 *     PlusOrMinus returns DapJtagSequence
	 *     PlusOrMinus.Plus_1_0_0_0 returns DapJtagSequence
	 *     PlusOrMinus.Minus_1_0_1_0 returns DapJtagSequence
	 *     MulOrDiv returns DapJtagSequence
	 *     MulOrDiv.Mul_1_0_0_0 returns DapJtagSequence
	 *     MulOrDiv.Div_1_0_1_0 returns DapJtagSequence
	 *     MulOrDiv.Rem_1_0_2_0 returns DapJtagSequence
	 *     Primary returns DapJtagSequence
	 *     Parameter returns DapJtagSequence
	 *     FunctionCall returns DapJtagSequence
	 *
	 * Constraint:
	 *     (cnt=Expression tms=Expression tdi=Expression)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, DapJtagSequence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DAP_JTAG_SEQUENCE__CNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DAP_JTAG_SEQUENCE__CNT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DAP_JTAG_SEQUENCE__TMS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DAP_JTAG_SEQUENCE__TMS));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DAP_JTAG_SEQUENCE__TDI) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DAP_JTAG_SEQUENCE__TDI));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getCntExpressionParserRuleCall_22_3_0(), semanticObject.getCnt());
		feeder.accept(grammarAccess.getFunctionCallAccess().getTmsExpressionParserRuleCall_22_5_0(), semanticObject.getTms());
		feeder.accept(grammarAccess.getFunctionCallAccess().getTdiExpressionParserRuleCall_22_7_0(), semanticObject.getTdi());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DapSwjClock
	 *     Expression returns DapSwjClock
	 *     Assignment returns DapSwjClock
	 *     Assignment.Assignment_1_0 returns DapSwjClock
	 *     Ternary returns DapSwjClock
	 *     Ternary.Ternary_1_0 returns DapSwjClock
	 *     Or returns DapSwjClock
	 *     Or.Or_1_0 returns DapSwjClock
	 *     And returns DapSwjClock
	 *     And.And_1_0 returns DapSwjClock
	 *     BitOr returns DapSwjClock
	 *     BitOr.BitOr_1_0 returns DapSwjClock
	 *     BitXor returns DapSwjClock
	 *     BitXor.BitXor_1_0 returns DapSwjClock
	 *     BitAnd returns DapSwjClock
	 *     BitAnd.BitAnd_1_0 returns DapSwjClock
	 *     Equality returns DapSwjClock
	 *     Equality.Equality_1_0 returns DapSwjClock
	 *     Comparison returns DapSwjClock
	 *     Comparison.Comparison_1_0 returns DapSwjClock
	 *     Shift returns DapSwjClock
	 *     Shift.Shift_1_0 returns DapSwjClock
	 *     PlusOrMinus returns DapSwjClock
	 *     PlusOrMinus.Plus_1_0_0_0 returns DapSwjClock
	 *     PlusOrMinus.Minus_1_0_1_0 returns DapSwjClock
	 *     MulOrDiv returns DapSwjClock
	 *     MulOrDiv.Mul_1_0_0_0 returns DapSwjClock
	 *     MulOrDiv.Div_1_0_1_0 returns DapSwjClock
	 *     MulOrDiv.Rem_1_0_2_0 returns DapSwjClock
	 *     Primary returns DapSwjClock
	 *     Parameter returns DapSwjClock
	 *     FunctionCall returns DapSwjClock
	 *
	 * Constraint:
	 *     value=Expression
	 */
	protected void sequence_FunctionCall(ISerializationContext context, DapSwjClock semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DAP_SWJ_CLOCK__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DAP_SWJ_CLOCK__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getValueExpressionParserRuleCall_20_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DapSwjPins
	 *     Expression returns DapSwjPins
	 *     Assignment returns DapSwjPins
	 *     Assignment.Assignment_1_0 returns DapSwjPins
	 *     Ternary returns DapSwjPins
	 *     Ternary.Ternary_1_0 returns DapSwjPins
	 *     Or returns DapSwjPins
	 *     Or.Or_1_0 returns DapSwjPins
	 *     And returns DapSwjPins
	 *     And.And_1_0 returns DapSwjPins
	 *     BitOr returns DapSwjPins
	 *     BitOr.BitOr_1_0 returns DapSwjPins
	 *     BitXor returns DapSwjPins
	 *     BitXor.BitXor_1_0 returns DapSwjPins
	 *     BitAnd returns DapSwjPins
	 *     BitAnd.BitAnd_1_0 returns DapSwjPins
	 *     Equality returns DapSwjPins
	 *     Equality.Equality_1_0 returns DapSwjPins
	 *     Comparison returns DapSwjPins
	 *     Comparison.Comparison_1_0 returns DapSwjPins
	 *     Shift returns DapSwjPins
	 *     Shift.Shift_1_0 returns DapSwjPins
	 *     PlusOrMinus returns DapSwjPins
	 *     PlusOrMinus.Plus_1_0_0_0 returns DapSwjPins
	 *     PlusOrMinus.Minus_1_0_1_0 returns DapSwjPins
	 *     MulOrDiv returns DapSwjPins
	 *     MulOrDiv.Mul_1_0_0_0 returns DapSwjPins
	 *     MulOrDiv.Div_1_0_1_0 returns DapSwjPins
	 *     MulOrDiv.Rem_1_0_2_0 returns DapSwjPins
	 *     Primary returns DapSwjPins
	 *     Parameter returns DapSwjPins
	 *     FunctionCall returns DapSwjPins
	 *
	 * Constraint:
	 *     (pinout=Expression pinselect=Expression pinwait=Expression)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, DapSwjPins semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DAP_SWJ_PINS__PINOUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DAP_SWJ_PINS__PINOUT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DAP_SWJ_PINS__PINSELECT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DAP_SWJ_PINS__PINSELECT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DAP_SWJ_PINS__PINWAIT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DAP_SWJ_PINS__PINWAIT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getPinoutExpressionParserRuleCall_19_3_0(), semanticObject.getPinout());
		feeder.accept(grammarAccess.getFunctionCallAccess().getPinselectExpressionParserRuleCall_19_5_0(), semanticObject.getPinselect());
		feeder.accept(grammarAccess.getFunctionCallAccess().getPinwaitExpressionParserRuleCall_19_7_0(), semanticObject.getPinwait());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DapSwjSequence
	 *     Expression returns DapSwjSequence
	 *     Assignment returns DapSwjSequence
	 *     Assignment.Assignment_1_0 returns DapSwjSequence
	 *     Ternary returns DapSwjSequence
	 *     Ternary.Ternary_1_0 returns DapSwjSequence
	 *     Or returns DapSwjSequence
	 *     Or.Or_1_0 returns DapSwjSequence
	 *     And returns DapSwjSequence
	 *     And.And_1_0 returns DapSwjSequence
	 *     BitOr returns DapSwjSequence
	 *     BitOr.BitOr_1_0 returns DapSwjSequence
	 *     BitXor returns DapSwjSequence
	 *     BitXor.BitXor_1_0 returns DapSwjSequence
	 *     BitAnd returns DapSwjSequence
	 *     BitAnd.BitAnd_1_0 returns DapSwjSequence
	 *     Equality returns DapSwjSequence
	 *     Equality.Equality_1_0 returns DapSwjSequence
	 *     Comparison returns DapSwjSequence
	 *     Comparison.Comparison_1_0 returns DapSwjSequence
	 *     Shift returns DapSwjSequence
	 *     Shift.Shift_1_0 returns DapSwjSequence
	 *     PlusOrMinus returns DapSwjSequence
	 *     PlusOrMinus.Plus_1_0_0_0 returns DapSwjSequence
	 *     PlusOrMinus.Minus_1_0_1_0 returns DapSwjSequence
	 *     MulOrDiv returns DapSwjSequence
	 *     MulOrDiv.Mul_1_0_0_0 returns DapSwjSequence
	 *     MulOrDiv.Div_1_0_1_0 returns DapSwjSequence
	 *     MulOrDiv.Rem_1_0_2_0 returns DapSwjSequence
	 *     Primary returns DapSwjSequence
	 *     Parameter returns DapSwjSequence
	 *     FunctionCall returns DapSwjSequence
	 *
	 * Constraint:
	 *     (cnt=Expression val=Expression)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, DapSwjSequence semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DAP_SWJ_SEQUENCE__CNT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DAP_SWJ_SEQUENCE__CNT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DAP_SWJ_SEQUENCE__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DAP_SWJ_SEQUENCE__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getCntExpressionParserRuleCall_21_3_0(), semanticObject.getCnt());
		feeder.accept(grammarAccess.getFunctionCallAccess().getValExpressionParserRuleCall_21_5_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns DapWriteABORT
	 *     Expression returns DapWriteABORT
	 *     Assignment returns DapWriteABORT
	 *     Assignment.Assignment_1_0 returns DapWriteABORT
	 *     Ternary returns DapWriteABORT
	 *     Ternary.Ternary_1_0 returns DapWriteABORT
	 *     Or returns DapWriteABORT
	 *     Or.Or_1_0 returns DapWriteABORT
	 *     And returns DapWriteABORT
	 *     And.And_1_0 returns DapWriteABORT
	 *     BitOr returns DapWriteABORT
	 *     BitOr.BitOr_1_0 returns DapWriteABORT
	 *     BitXor returns DapWriteABORT
	 *     BitXor.BitXor_1_0 returns DapWriteABORT
	 *     BitAnd returns DapWriteABORT
	 *     BitAnd.BitAnd_1_0 returns DapWriteABORT
	 *     Equality returns DapWriteABORT
	 *     Equality.Equality_1_0 returns DapWriteABORT
	 *     Comparison returns DapWriteABORT
	 *     Comparison.Comparison_1_0 returns DapWriteABORT
	 *     Shift returns DapWriteABORT
	 *     Shift.Shift_1_0 returns DapWriteABORT
	 *     PlusOrMinus returns DapWriteABORT
	 *     PlusOrMinus.Plus_1_0_0_0 returns DapWriteABORT
	 *     PlusOrMinus.Minus_1_0_1_0 returns DapWriteABORT
	 *     MulOrDiv returns DapWriteABORT
	 *     MulOrDiv.Mul_1_0_0_0 returns DapWriteABORT
	 *     MulOrDiv.Div_1_0_1_0 returns DapWriteABORT
	 *     MulOrDiv.Rem_1_0_2_0 returns DapWriteABORT
	 *     Primary returns DapWriteABORT
	 *     Parameter returns DapWriteABORT
	 *     FunctionCall returns DapWriteABORT
	 *
	 * Constraint:
	 *     value=Expression
	 */
	protected void sequence_FunctionCall(ISerializationContext context, DapWriteABORT semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DAP_WRITE_ABORT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DAP_WRITE_ABORT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getValueExpressionParserRuleCall_18_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns LoadDebugInfo
	 *     Expression returns LoadDebugInfo
	 *     Assignment returns LoadDebugInfo
	 *     Assignment.Assignment_1_0 returns LoadDebugInfo
	 *     Ternary returns LoadDebugInfo
	 *     Ternary.Ternary_1_0 returns LoadDebugInfo
	 *     Or returns LoadDebugInfo
	 *     Or.Or_1_0 returns LoadDebugInfo
	 *     And returns LoadDebugInfo
	 *     And.And_1_0 returns LoadDebugInfo
	 *     BitOr returns LoadDebugInfo
	 *     BitOr.BitOr_1_0 returns LoadDebugInfo
	 *     BitXor returns LoadDebugInfo
	 *     BitXor.BitXor_1_0 returns LoadDebugInfo
	 *     BitAnd returns LoadDebugInfo
	 *     BitAnd.BitAnd_1_0 returns LoadDebugInfo
	 *     Equality returns LoadDebugInfo
	 *     Equality.Equality_1_0 returns LoadDebugInfo
	 *     Comparison returns LoadDebugInfo
	 *     Comparison.Comparison_1_0 returns LoadDebugInfo
	 *     Shift returns LoadDebugInfo
	 *     Shift.Shift_1_0 returns LoadDebugInfo
	 *     PlusOrMinus returns LoadDebugInfo
	 *     PlusOrMinus.Plus_1_0_0_0 returns LoadDebugInfo
	 *     PlusOrMinus.Minus_1_0_1_0 returns LoadDebugInfo
	 *     MulOrDiv returns LoadDebugInfo
	 *     MulOrDiv.Mul_1_0_0_0 returns LoadDebugInfo
	 *     MulOrDiv.Div_1_0_1_0 returns LoadDebugInfo
	 *     MulOrDiv.Rem_1_0_2_0 returns LoadDebugInfo
	 *     Primary returns LoadDebugInfo
	 *     Parameter returns LoadDebugInfo
	 *     FunctionCall returns LoadDebugInfo
	 *
	 * Constraint:
	 *     path=STRING
	 */
	protected void sequence_FunctionCall(ISerializationContext context, LoadDebugInfo semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.LOAD_DEBUG_INFO__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.LOAD_DEBUG_INFO__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getPathSTRINGTerminalRuleCall_4_3_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Message
	 *     Expression returns Message
	 *     Assignment returns Message
	 *     Assignment.Assignment_1_0 returns Message
	 *     Ternary returns Message
	 *     Ternary.Ternary_1_0 returns Message
	 *     Or returns Message
	 *     Or.Or_1_0 returns Message
	 *     And returns Message
	 *     And.And_1_0 returns Message
	 *     BitOr returns Message
	 *     BitOr.BitOr_1_0 returns Message
	 *     BitXor returns Message
	 *     BitXor.BitXor_1_0 returns Message
	 *     BitAnd returns Message
	 *     BitAnd.BitAnd_1_0 returns Message
	 *     Equality returns Message
	 *     Equality.Equality_1_0 returns Message
	 *     Comparison returns Message
	 *     Comparison.Comparison_1_0 returns Message
	 *     Shift returns Message
	 *     Shift.Shift_1_0 returns Message
	 *     PlusOrMinus returns Message
	 *     PlusOrMinus.Plus_1_0_0_0 returns Message
	 *     PlusOrMinus.Minus_1_0_1_0 returns Message
	 *     MulOrDiv returns Message
	 *     MulOrDiv.Mul_1_0_0_0 returns Message
	 *     MulOrDiv.Div_1_0_1_0 returns Message
	 *     MulOrDiv.Rem_1_0_2_0 returns Message
	 *     Primary returns Message
	 *     Parameter returns Message
	 *     FunctionCall returns Message
	 *
	 * Constraint:
	 *     (type=Expression format=STRING parameters+=Parameter*)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, Message semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Query
	 *     Expression returns Query
	 *     Assignment returns Query
	 *     Assignment.Assignment_1_0 returns Query
	 *     Ternary returns Query
	 *     Ternary.Ternary_1_0 returns Query
	 *     Or returns Query
	 *     Or.Or_1_0 returns Query
	 *     And returns Query
	 *     And.And_1_0 returns Query
	 *     BitOr returns Query
	 *     BitOr.BitOr_1_0 returns Query
	 *     BitXor returns Query
	 *     BitXor.BitXor_1_0 returns Query
	 *     BitAnd returns Query
	 *     BitAnd.BitAnd_1_0 returns Query
	 *     Equality returns Query
	 *     Equality.Equality_1_0 returns Query
	 *     Comparison returns Query
	 *     Comparison.Comparison_1_0 returns Query
	 *     Shift returns Query
	 *     Shift.Shift_1_0 returns Query
	 *     PlusOrMinus returns Query
	 *     PlusOrMinus.Plus_1_0_0_0 returns Query
	 *     PlusOrMinus.Minus_1_0_1_0 returns Query
	 *     MulOrDiv returns Query
	 *     MulOrDiv.Mul_1_0_0_0 returns Query
	 *     MulOrDiv.Div_1_0_1_0 returns Query
	 *     MulOrDiv.Rem_1_0_2_0 returns Query
	 *     Primary returns Query
	 *     Parameter returns Query
	 *     FunctionCall returns Query
	 *
	 * Constraint:
	 *     (type=Expression message=STRING default=Expression)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, Query semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.QUERY__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.QUERY__TYPE));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.QUERY__MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.QUERY__MESSAGE));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.QUERY__DEFAULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.QUERY__DEFAULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getTypeExpressionParserRuleCall_1_3_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getFunctionCallAccess().getMessageSTRINGTerminalRuleCall_1_5_0(), semanticObject.getMessage());
		feeder.accept(grammarAccess.getFunctionCallAccess().getDefaultExpressionParserRuleCall_1_7_0(), semanticObject.getDefault());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns QueryValue
	 *     Expression returns QueryValue
	 *     Assignment returns QueryValue
	 *     Assignment.Assignment_1_0 returns QueryValue
	 *     Ternary returns QueryValue
	 *     Ternary.Ternary_1_0 returns QueryValue
	 *     Or returns QueryValue
	 *     Or.Or_1_0 returns QueryValue
	 *     And returns QueryValue
	 *     And.And_1_0 returns QueryValue
	 *     BitOr returns QueryValue
	 *     BitOr.BitOr_1_0 returns QueryValue
	 *     BitXor returns QueryValue
	 *     BitXor.BitXor_1_0 returns QueryValue
	 *     BitAnd returns QueryValue
	 *     BitAnd.BitAnd_1_0 returns QueryValue
	 *     Equality returns QueryValue
	 *     Equality.Equality_1_0 returns QueryValue
	 *     Comparison returns QueryValue
	 *     Comparison.Comparison_1_0 returns QueryValue
	 *     Shift returns QueryValue
	 *     Shift.Shift_1_0 returns QueryValue
	 *     PlusOrMinus returns QueryValue
	 *     PlusOrMinus.Plus_1_0_0_0 returns QueryValue
	 *     PlusOrMinus.Minus_1_0_1_0 returns QueryValue
	 *     MulOrDiv returns QueryValue
	 *     MulOrDiv.Mul_1_0_0_0 returns QueryValue
	 *     MulOrDiv.Div_1_0_1_0 returns QueryValue
	 *     MulOrDiv.Rem_1_0_2_0 returns QueryValue
	 *     Primary returns QueryValue
	 *     Parameter returns QueryValue
	 *     FunctionCall returns QueryValue
	 *
	 * Constraint:
	 *     (message=STRING default=Expression)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, QueryValue semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.QUERY_VALUE__MESSAGE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.QUERY_VALUE__MESSAGE));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.QUERY_VALUE__DEFAULT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.QUERY_VALUE__DEFAULT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getMessageSTRINGTerminalRuleCall_2_3_0(), semanticObject.getMessage());
		feeder.accept(grammarAccess.getFunctionCallAccess().getDefaultExpressionParserRuleCall_2_5_0(), semanticObject.getDefault());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Read16
	 *     Expression returns Read16
	 *     Assignment returns Read16
	 *     Assignment.Assignment_1_0 returns Read16
	 *     Ternary returns Read16
	 *     Ternary.Ternary_1_0 returns Read16
	 *     Or returns Read16
	 *     Or.Or_1_0 returns Read16
	 *     And returns Read16
	 *     And.And_1_0 returns Read16
	 *     BitOr returns Read16
	 *     BitOr.BitOr_1_0 returns Read16
	 *     BitXor returns Read16
	 *     BitXor.BitXor_1_0 returns Read16
	 *     BitAnd returns Read16
	 *     BitAnd.BitAnd_1_0 returns Read16
	 *     Equality returns Read16
	 *     Equality.Equality_1_0 returns Read16
	 *     Comparison returns Read16
	 *     Comparison.Comparison_1_0 returns Read16
	 *     Shift returns Read16
	 *     Shift.Shift_1_0 returns Read16
	 *     PlusOrMinus returns Read16
	 *     PlusOrMinus.Plus_1_0_0_0 returns Read16
	 *     PlusOrMinus.Minus_1_0_1_0 returns Read16
	 *     MulOrDiv returns Read16
	 *     MulOrDiv.Mul_1_0_0_0 returns Read16
	 *     MulOrDiv.Div_1_0_1_0 returns Read16
	 *     MulOrDiv.Rem_1_0_2_0 returns Read16
	 *     Primary returns Read16
	 *     Parameter returns Read16
	 *     FunctionCall returns Read16
	 *
	 * Constraint:
	 *     addr=Expression
	 */
	protected void sequence_FunctionCall(ISerializationContext context, Read16 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.READ16__ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.READ16__ADDR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getAddrExpressionParserRuleCall_6_3_0(), semanticObject.getAddr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Read32
	 *     Expression returns Read32
	 *     Assignment returns Read32
	 *     Assignment.Assignment_1_0 returns Read32
	 *     Ternary returns Read32
	 *     Ternary.Ternary_1_0 returns Read32
	 *     Or returns Read32
	 *     Or.Or_1_0 returns Read32
	 *     And returns Read32
	 *     And.And_1_0 returns Read32
	 *     BitOr returns Read32
	 *     BitOr.BitOr_1_0 returns Read32
	 *     BitXor returns Read32
	 *     BitXor.BitXor_1_0 returns Read32
	 *     BitAnd returns Read32
	 *     BitAnd.BitAnd_1_0 returns Read32
	 *     Equality returns Read32
	 *     Equality.Equality_1_0 returns Read32
	 *     Comparison returns Read32
	 *     Comparison.Comparison_1_0 returns Read32
	 *     Shift returns Read32
	 *     Shift.Shift_1_0 returns Read32
	 *     PlusOrMinus returns Read32
	 *     PlusOrMinus.Plus_1_0_0_0 returns Read32
	 *     PlusOrMinus.Minus_1_0_1_0 returns Read32
	 *     MulOrDiv returns Read32
	 *     MulOrDiv.Mul_1_0_0_0 returns Read32
	 *     MulOrDiv.Div_1_0_1_0 returns Read32
	 *     MulOrDiv.Rem_1_0_2_0 returns Read32
	 *     Primary returns Read32
	 *     Parameter returns Read32
	 *     FunctionCall returns Read32
	 *
	 * Constraint:
	 *     addr=Expression
	 */
	protected void sequence_FunctionCall(ISerializationContext context, Read32 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.READ32__ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.READ32__ADDR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getAddrExpressionParserRuleCall_7_3_0(), semanticObject.getAddr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Read64
	 *     Expression returns Read64
	 *     Assignment returns Read64
	 *     Assignment.Assignment_1_0 returns Read64
	 *     Ternary returns Read64
	 *     Ternary.Ternary_1_0 returns Read64
	 *     Or returns Read64
	 *     Or.Or_1_0 returns Read64
	 *     And returns Read64
	 *     And.And_1_0 returns Read64
	 *     BitOr returns Read64
	 *     BitOr.BitOr_1_0 returns Read64
	 *     BitXor returns Read64
	 *     BitXor.BitXor_1_0 returns Read64
	 *     BitAnd returns Read64
	 *     BitAnd.BitAnd_1_0 returns Read64
	 *     Equality returns Read64
	 *     Equality.Equality_1_0 returns Read64
	 *     Comparison returns Read64
	 *     Comparison.Comparison_1_0 returns Read64
	 *     Shift returns Read64
	 *     Shift.Shift_1_0 returns Read64
	 *     PlusOrMinus returns Read64
	 *     PlusOrMinus.Plus_1_0_0_0 returns Read64
	 *     PlusOrMinus.Minus_1_0_1_0 returns Read64
	 *     MulOrDiv returns Read64
	 *     MulOrDiv.Mul_1_0_0_0 returns Read64
	 *     MulOrDiv.Div_1_0_1_0 returns Read64
	 *     MulOrDiv.Rem_1_0_2_0 returns Read64
	 *     Primary returns Read64
	 *     Parameter returns Read64
	 *     FunctionCall returns Read64
	 *
	 * Constraint:
	 *     addr=Expression
	 */
	protected void sequence_FunctionCall(ISerializationContext context, Read64 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.READ64__ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.READ64__ADDR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getAddrExpressionParserRuleCall_8_3_0(), semanticObject.getAddr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Read8
	 *     Expression returns Read8
	 *     Assignment returns Read8
	 *     Assignment.Assignment_1_0 returns Read8
	 *     Ternary returns Read8
	 *     Ternary.Ternary_1_0 returns Read8
	 *     Or returns Read8
	 *     Or.Or_1_0 returns Read8
	 *     And returns Read8
	 *     And.And_1_0 returns Read8
	 *     BitOr returns Read8
	 *     BitOr.BitOr_1_0 returns Read8
	 *     BitXor returns Read8
	 *     BitXor.BitXor_1_0 returns Read8
	 *     BitAnd returns Read8
	 *     BitAnd.BitAnd_1_0 returns Read8
	 *     Equality returns Read8
	 *     Equality.Equality_1_0 returns Read8
	 *     Comparison returns Read8
	 *     Comparison.Comparison_1_0 returns Read8
	 *     Shift returns Read8
	 *     Shift.Shift_1_0 returns Read8
	 *     PlusOrMinus returns Read8
	 *     PlusOrMinus.Plus_1_0_0_0 returns Read8
	 *     PlusOrMinus.Minus_1_0_1_0 returns Read8
	 *     MulOrDiv returns Read8
	 *     MulOrDiv.Mul_1_0_0_0 returns Read8
	 *     MulOrDiv.Div_1_0_1_0 returns Read8
	 *     MulOrDiv.Rem_1_0_2_0 returns Read8
	 *     Primary returns Read8
	 *     Parameter returns Read8
	 *     FunctionCall returns Read8
	 *
	 * Constraint:
	 *     addr=Expression
	 */
	protected void sequence_FunctionCall(ISerializationContext context, Read8 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.READ8__ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.READ8__ADDR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getAddrExpressionParserRuleCall_5_3_0(), semanticObject.getAddr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReadAP
	 *     Expression returns ReadAP
	 *     Assignment returns ReadAP
	 *     Assignment.Assignment_1_0 returns ReadAP
	 *     Ternary returns ReadAP
	 *     Ternary.Ternary_1_0 returns ReadAP
	 *     Or returns ReadAP
	 *     Or.Or_1_0 returns ReadAP
	 *     And returns ReadAP
	 *     And.And_1_0 returns ReadAP
	 *     BitOr returns ReadAP
	 *     BitOr.BitOr_1_0 returns ReadAP
	 *     BitXor returns ReadAP
	 *     BitXor.BitXor_1_0 returns ReadAP
	 *     BitAnd returns ReadAP
	 *     BitAnd.BitAnd_1_0 returns ReadAP
	 *     Equality returns ReadAP
	 *     Equality.Equality_1_0 returns ReadAP
	 *     Comparison returns ReadAP
	 *     Comparison.Comparison_1_0 returns ReadAP
	 *     Shift returns ReadAP
	 *     Shift.Shift_1_0 returns ReadAP
	 *     PlusOrMinus returns ReadAP
	 *     PlusOrMinus.Plus_1_0_0_0 returns ReadAP
	 *     PlusOrMinus.Minus_1_0_1_0 returns ReadAP
	 *     MulOrDiv returns ReadAP
	 *     MulOrDiv.Mul_1_0_0_0 returns ReadAP
	 *     MulOrDiv.Div_1_0_1_0 returns ReadAP
	 *     MulOrDiv.Rem_1_0_2_0 returns ReadAP
	 *     Primary returns ReadAP
	 *     Parameter returns ReadAP
	 *     FunctionCall returns ReadAP
	 *
	 * Constraint:
	 *     addr=Expression
	 */
	protected void sequence_FunctionCall(ISerializationContext context, ReadAP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.READ_AP__ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.READ_AP__ADDR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getAddrExpressionParserRuleCall_9_3_0(), semanticObject.getAddr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns ReadDP
	 *     Expression returns ReadDP
	 *     Assignment returns ReadDP
	 *     Assignment.Assignment_1_0 returns ReadDP
	 *     Ternary returns ReadDP
	 *     Ternary.Ternary_1_0 returns ReadDP
	 *     Or returns ReadDP
	 *     Or.Or_1_0 returns ReadDP
	 *     And returns ReadDP
	 *     And.And_1_0 returns ReadDP
	 *     BitOr returns ReadDP
	 *     BitOr.BitOr_1_0 returns ReadDP
	 *     BitXor returns ReadDP
	 *     BitXor.BitXor_1_0 returns ReadDP
	 *     BitAnd returns ReadDP
	 *     BitAnd.BitAnd_1_0 returns ReadDP
	 *     Equality returns ReadDP
	 *     Equality.Equality_1_0 returns ReadDP
	 *     Comparison returns ReadDP
	 *     Comparison.Comparison_1_0 returns ReadDP
	 *     Shift returns ReadDP
	 *     Shift.Shift_1_0 returns ReadDP
	 *     PlusOrMinus returns ReadDP
	 *     PlusOrMinus.Plus_1_0_0_0 returns ReadDP
	 *     PlusOrMinus.Minus_1_0_1_0 returns ReadDP
	 *     MulOrDiv returns ReadDP
	 *     MulOrDiv.Mul_1_0_0_0 returns ReadDP
	 *     MulOrDiv.Div_1_0_1_0 returns ReadDP
	 *     MulOrDiv.Rem_1_0_2_0 returns ReadDP
	 *     Primary returns ReadDP
	 *     Parameter returns ReadDP
	 *     FunctionCall returns ReadDP
	 *
	 * Constraint:
	 *     addr=Expression
	 */
	protected void sequence_FunctionCall(ISerializationContext context, ReadDP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.READ_DP__ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.READ_DP__ADDR));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getAddrExpressionParserRuleCall_10_3_0(), semanticObject.getAddr());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns SequenceCall
	 *     Expression returns SequenceCall
	 *     Assignment returns SequenceCall
	 *     Assignment.Assignment_1_0 returns SequenceCall
	 *     Ternary returns SequenceCall
	 *     Ternary.Ternary_1_0 returns SequenceCall
	 *     Or returns SequenceCall
	 *     Or.Or_1_0 returns SequenceCall
	 *     And returns SequenceCall
	 *     And.And_1_0 returns SequenceCall
	 *     BitOr returns SequenceCall
	 *     BitOr.BitOr_1_0 returns SequenceCall
	 *     BitXor returns SequenceCall
	 *     BitXor.BitXor_1_0 returns SequenceCall
	 *     BitAnd returns SequenceCall
	 *     BitAnd.BitAnd_1_0 returns SequenceCall
	 *     Equality returns SequenceCall
	 *     Equality.Equality_1_0 returns SequenceCall
	 *     Comparison returns SequenceCall
	 *     Comparison.Comparison_1_0 returns SequenceCall
	 *     Shift returns SequenceCall
	 *     Shift.Shift_1_0 returns SequenceCall
	 *     PlusOrMinus returns SequenceCall
	 *     PlusOrMinus.Plus_1_0_0_0 returns SequenceCall
	 *     PlusOrMinus.Minus_1_0_1_0 returns SequenceCall
	 *     MulOrDiv returns SequenceCall
	 *     MulOrDiv.Mul_1_0_0_0 returns SequenceCall
	 *     MulOrDiv.Div_1_0_1_0 returns SequenceCall
	 *     MulOrDiv.Rem_1_0_2_0 returns SequenceCall
	 *     Primary returns SequenceCall
	 *     Parameter returns SequenceCall
	 *     FunctionCall returns SequenceCall
	 *
	 * Constraint:
	 *     seqname=ID
	 */
	protected void sequence_FunctionCall(ISerializationContext context, SequenceCall semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.SEQUENCE_CALL__SEQNAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.SEQUENCE_CALL__SEQNAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getSeqnameIDTerminalRuleCall_0_4_0(), semanticObject.getSeqname());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Write16
	 *     Expression returns Write16
	 *     Assignment returns Write16
	 *     Assignment.Assignment_1_0 returns Write16
	 *     Ternary returns Write16
	 *     Ternary.Ternary_1_0 returns Write16
	 *     Or returns Write16
	 *     Or.Or_1_0 returns Write16
	 *     And returns Write16
	 *     And.And_1_0 returns Write16
	 *     BitOr returns Write16
	 *     BitOr.BitOr_1_0 returns Write16
	 *     BitXor returns Write16
	 *     BitXor.BitXor_1_0 returns Write16
	 *     BitAnd returns Write16
	 *     BitAnd.BitAnd_1_0 returns Write16
	 *     Equality returns Write16
	 *     Equality.Equality_1_0 returns Write16
	 *     Comparison returns Write16
	 *     Comparison.Comparison_1_0 returns Write16
	 *     Shift returns Write16
	 *     Shift.Shift_1_0 returns Write16
	 *     PlusOrMinus returns Write16
	 *     PlusOrMinus.Plus_1_0_0_0 returns Write16
	 *     PlusOrMinus.Minus_1_0_1_0 returns Write16
	 *     MulOrDiv returns Write16
	 *     MulOrDiv.Mul_1_0_0_0 returns Write16
	 *     MulOrDiv.Div_1_0_1_0 returns Write16
	 *     MulOrDiv.Rem_1_0_2_0 returns Write16
	 *     Primary returns Write16
	 *     Parameter returns Write16
	 *     FunctionCall returns Write16
	 *
	 * Constraint:
	 *     (addr=Expression val=Expression)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, Write16 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.WRITE16__ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.WRITE16__ADDR));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.WRITE16__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.WRITE16__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getAddrExpressionParserRuleCall_12_3_0(), semanticObject.getAddr());
		feeder.accept(grammarAccess.getFunctionCallAccess().getValExpressionParserRuleCall_12_5_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Write32
	 *     Expression returns Write32
	 *     Assignment returns Write32
	 *     Assignment.Assignment_1_0 returns Write32
	 *     Ternary returns Write32
	 *     Ternary.Ternary_1_0 returns Write32
	 *     Or returns Write32
	 *     Or.Or_1_0 returns Write32
	 *     And returns Write32
	 *     And.And_1_0 returns Write32
	 *     BitOr returns Write32
	 *     BitOr.BitOr_1_0 returns Write32
	 *     BitXor returns Write32
	 *     BitXor.BitXor_1_0 returns Write32
	 *     BitAnd returns Write32
	 *     BitAnd.BitAnd_1_0 returns Write32
	 *     Equality returns Write32
	 *     Equality.Equality_1_0 returns Write32
	 *     Comparison returns Write32
	 *     Comparison.Comparison_1_0 returns Write32
	 *     Shift returns Write32
	 *     Shift.Shift_1_0 returns Write32
	 *     PlusOrMinus returns Write32
	 *     PlusOrMinus.Plus_1_0_0_0 returns Write32
	 *     PlusOrMinus.Minus_1_0_1_0 returns Write32
	 *     MulOrDiv returns Write32
	 *     MulOrDiv.Mul_1_0_0_0 returns Write32
	 *     MulOrDiv.Div_1_0_1_0 returns Write32
	 *     MulOrDiv.Rem_1_0_2_0 returns Write32
	 *     Primary returns Write32
	 *     Parameter returns Write32
	 *     FunctionCall returns Write32
	 *
	 * Constraint:
	 *     (addr=Expression val=Expression)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, Write32 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.WRITE32__ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.WRITE32__ADDR));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.WRITE32__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.WRITE32__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getAddrExpressionParserRuleCall_13_3_0(), semanticObject.getAddr());
		feeder.accept(grammarAccess.getFunctionCallAccess().getValExpressionParserRuleCall_13_5_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Write64
	 *     Expression returns Write64
	 *     Assignment returns Write64
	 *     Assignment.Assignment_1_0 returns Write64
	 *     Ternary returns Write64
	 *     Ternary.Ternary_1_0 returns Write64
	 *     Or returns Write64
	 *     Or.Or_1_0 returns Write64
	 *     And returns Write64
	 *     And.And_1_0 returns Write64
	 *     BitOr returns Write64
	 *     BitOr.BitOr_1_0 returns Write64
	 *     BitXor returns Write64
	 *     BitXor.BitXor_1_0 returns Write64
	 *     BitAnd returns Write64
	 *     BitAnd.BitAnd_1_0 returns Write64
	 *     Equality returns Write64
	 *     Equality.Equality_1_0 returns Write64
	 *     Comparison returns Write64
	 *     Comparison.Comparison_1_0 returns Write64
	 *     Shift returns Write64
	 *     Shift.Shift_1_0 returns Write64
	 *     PlusOrMinus returns Write64
	 *     PlusOrMinus.Plus_1_0_0_0 returns Write64
	 *     PlusOrMinus.Minus_1_0_1_0 returns Write64
	 *     MulOrDiv returns Write64
	 *     MulOrDiv.Mul_1_0_0_0 returns Write64
	 *     MulOrDiv.Div_1_0_1_0 returns Write64
	 *     MulOrDiv.Rem_1_0_2_0 returns Write64
	 *     Primary returns Write64
	 *     Parameter returns Write64
	 *     FunctionCall returns Write64
	 *
	 * Constraint:
	 *     (addr=Expression val=Expression)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, Write64 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.WRITE64__ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.WRITE64__ADDR));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.WRITE64__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.WRITE64__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getAddrExpressionParserRuleCall_14_3_0(), semanticObject.getAddr());
		feeder.accept(grammarAccess.getFunctionCallAccess().getValExpressionParserRuleCall_14_5_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Write8
	 *     Expression returns Write8
	 *     Assignment returns Write8
	 *     Assignment.Assignment_1_0 returns Write8
	 *     Ternary returns Write8
	 *     Ternary.Ternary_1_0 returns Write8
	 *     Or returns Write8
	 *     Or.Or_1_0 returns Write8
	 *     And returns Write8
	 *     And.And_1_0 returns Write8
	 *     BitOr returns Write8
	 *     BitOr.BitOr_1_0 returns Write8
	 *     BitXor returns Write8
	 *     BitXor.BitXor_1_0 returns Write8
	 *     BitAnd returns Write8
	 *     BitAnd.BitAnd_1_0 returns Write8
	 *     Equality returns Write8
	 *     Equality.Equality_1_0 returns Write8
	 *     Comparison returns Write8
	 *     Comparison.Comparison_1_0 returns Write8
	 *     Shift returns Write8
	 *     Shift.Shift_1_0 returns Write8
	 *     PlusOrMinus returns Write8
	 *     PlusOrMinus.Plus_1_0_0_0 returns Write8
	 *     PlusOrMinus.Minus_1_0_1_0 returns Write8
	 *     MulOrDiv returns Write8
	 *     MulOrDiv.Mul_1_0_0_0 returns Write8
	 *     MulOrDiv.Div_1_0_1_0 returns Write8
	 *     MulOrDiv.Rem_1_0_2_0 returns Write8
	 *     Primary returns Write8
	 *     Parameter returns Write8
	 *     FunctionCall returns Write8
	 *
	 * Constraint:
	 *     (addr=Expression val=Expression)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, Write8 semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.WRITE8__ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.WRITE8__ADDR));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.WRITE8__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.WRITE8__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getAddrExpressionParserRuleCall_11_3_0(), semanticObject.getAddr());
		feeder.accept(grammarAccess.getFunctionCallAccess().getValExpressionParserRuleCall_11_5_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WriteAP
	 *     Expression returns WriteAP
	 *     Assignment returns WriteAP
	 *     Assignment.Assignment_1_0 returns WriteAP
	 *     Ternary returns WriteAP
	 *     Ternary.Ternary_1_0 returns WriteAP
	 *     Or returns WriteAP
	 *     Or.Or_1_0 returns WriteAP
	 *     And returns WriteAP
	 *     And.And_1_0 returns WriteAP
	 *     BitOr returns WriteAP
	 *     BitOr.BitOr_1_0 returns WriteAP
	 *     BitXor returns WriteAP
	 *     BitXor.BitXor_1_0 returns WriteAP
	 *     BitAnd returns WriteAP
	 *     BitAnd.BitAnd_1_0 returns WriteAP
	 *     Equality returns WriteAP
	 *     Equality.Equality_1_0 returns WriteAP
	 *     Comparison returns WriteAP
	 *     Comparison.Comparison_1_0 returns WriteAP
	 *     Shift returns WriteAP
	 *     Shift.Shift_1_0 returns WriteAP
	 *     PlusOrMinus returns WriteAP
	 *     PlusOrMinus.Plus_1_0_0_0 returns WriteAP
	 *     PlusOrMinus.Minus_1_0_1_0 returns WriteAP
	 *     MulOrDiv returns WriteAP
	 *     MulOrDiv.Mul_1_0_0_0 returns WriteAP
	 *     MulOrDiv.Div_1_0_1_0 returns WriteAP
	 *     MulOrDiv.Rem_1_0_2_0 returns WriteAP
	 *     Primary returns WriteAP
	 *     Parameter returns WriteAP
	 *     FunctionCall returns WriteAP
	 *
	 * Constraint:
	 *     (addr=Expression val=Expression)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, WriteAP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.WRITE_AP__ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.WRITE_AP__ADDR));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.WRITE_AP__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.WRITE_AP__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getAddrExpressionParserRuleCall_15_3_0(), semanticObject.getAddr());
		feeder.accept(grammarAccess.getFunctionCallAccess().getValExpressionParserRuleCall_15_5_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns WriteDP
	 *     Expression returns WriteDP
	 *     Assignment returns WriteDP
	 *     Assignment.Assignment_1_0 returns WriteDP
	 *     Ternary returns WriteDP
	 *     Ternary.Ternary_1_0 returns WriteDP
	 *     Or returns WriteDP
	 *     Or.Or_1_0 returns WriteDP
	 *     And returns WriteDP
	 *     And.And_1_0 returns WriteDP
	 *     BitOr returns WriteDP
	 *     BitOr.BitOr_1_0 returns WriteDP
	 *     BitXor returns WriteDP
	 *     BitXor.BitXor_1_0 returns WriteDP
	 *     BitAnd returns WriteDP
	 *     BitAnd.BitAnd_1_0 returns WriteDP
	 *     Equality returns WriteDP
	 *     Equality.Equality_1_0 returns WriteDP
	 *     Comparison returns WriteDP
	 *     Comparison.Comparison_1_0 returns WriteDP
	 *     Shift returns WriteDP
	 *     Shift.Shift_1_0 returns WriteDP
	 *     PlusOrMinus returns WriteDP
	 *     PlusOrMinus.Plus_1_0_0_0 returns WriteDP
	 *     PlusOrMinus.Minus_1_0_1_0 returns WriteDP
	 *     MulOrDiv returns WriteDP
	 *     MulOrDiv.Mul_1_0_0_0 returns WriteDP
	 *     MulOrDiv.Div_1_0_1_0 returns WriteDP
	 *     MulOrDiv.Rem_1_0_2_0 returns WriteDP
	 *     Primary returns WriteDP
	 *     Parameter returns WriteDP
	 *     FunctionCall returns WriteDP
	 *
	 * Constraint:
	 *     (addr=Expression val=Expression)
	 */
	protected void sequence_FunctionCall(ISerializationContext context, WriteDP semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.WRITE_DP__ADDR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.WRITE_DP__ADDR));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.WRITE_DP__VAL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.WRITE_DP__VAL));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFunctionCallAccess().getAddrExpressionParserRuleCall_16_3_0(), semanticObject.getAddr());
		feeder.accept(grammarAccess.getFunctionCallAccess().getValExpressionParserRuleCall_16_5_0(), semanticObject.getVal());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Div
	 *     Expression returns Div
	 *     Assignment returns Div
	 *     Assignment.Assignment_1_0 returns Div
	 *     Ternary returns Div
	 *     Ternary.Ternary_1_0 returns Div
	 *     Or returns Div
	 *     Or.Or_1_0 returns Div
	 *     And returns Div
	 *     And.And_1_0 returns Div
	 *     BitOr returns Div
	 *     BitOr.BitOr_1_0 returns Div
	 *     BitXor returns Div
	 *     BitXor.BitXor_1_0 returns Div
	 *     BitAnd returns Div
	 *     BitAnd.BitAnd_1_0 returns Div
	 *     Equality returns Div
	 *     Equality.Equality_1_0 returns Div
	 *     Comparison returns Div
	 *     Comparison.Comparison_1_0 returns Div
	 *     Shift returns Div
	 *     Shift.Shift_1_0 returns Div
	 *     PlusOrMinus returns Div
	 *     PlusOrMinus.Plus_1_0_0_0 returns Div
	 *     PlusOrMinus.Minus_1_0_1_0 returns Div
	 *     MulOrDiv returns Div
	 *     MulOrDiv.Mul_1_0_0_0 returns Div
	 *     MulOrDiv.Div_1_0_1_0 returns Div
	 *     MulOrDiv.Rem_1_0_2_0 returns Div
	 *     Primary returns Div
	 *     Parameter returns Div
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Div_1_0_1_0 right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Div semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DIV__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DIV__LEFT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.DIV__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.DIV__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getDivLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Mul
	 *     Expression returns Mul
	 *     Assignment returns Mul
	 *     Assignment.Assignment_1_0 returns Mul
	 *     Ternary returns Mul
	 *     Ternary.Ternary_1_0 returns Mul
	 *     Or returns Mul
	 *     Or.Or_1_0 returns Mul
	 *     And returns Mul
	 *     And.And_1_0 returns Mul
	 *     BitOr returns Mul
	 *     BitOr.BitOr_1_0 returns Mul
	 *     BitXor returns Mul
	 *     BitXor.BitXor_1_0 returns Mul
	 *     BitAnd returns Mul
	 *     BitAnd.BitAnd_1_0 returns Mul
	 *     Equality returns Mul
	 *     Equality.Equality_1_0 returns Mul
	 *     Comparison returns Mul
	 *     Comparison.Comparison_1_0 returns Mul
	 *     Shift returns Mul
	 *     Shift.Shift_1_0 returns Mul
	 *     PlusOrMinus returns Mul
	 *     PlusOrMinus.Plus_1_0_0_0 returns Mul
	 *     PlusOrMinus.Minus_1_0_1_0 returns Mul
	 *     MulOrDiv returns Mul
	 *     MulOrDiv.Mul_1_0_0_0 returns Mul
	 *     MulOrDiv.Div_1_0_1_0 returns Mul
	 *     MulOrDiv.Rem_1_0_2_0 returns Mul
	 *     Primary returns Mul
	 *     Parameter returns Mul
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Mul_1_0_0_0 right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Mul semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.MUL__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.MUL__LEFT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.MUL__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.MUL__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getMulLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Rem
	 *     Expression returns Rem
	 *     Assignment returns Rem
	 *     Assignment.Assignment_1_0 returns Rem
	 *     Ternary returns Rem
	 *     Ternary.Ternary_1_0 returns Rem
	 *     Or returns Rem
	 *     Or.Or_1_0 returns Rem
	 *     And returns Rem
	 *     And.And_1_0 returns Rem
	 *     BitOr returns Rem
	 *     BitOr.BitOr_1_0 returns Rem
	 *     BitXor returns Rem
	 *     BitXor.BitXor_1_0 returns Rem
	 *     BitAnd returns Rem
	 *     BitAnd.BitAnd_1_0 returns Rem
	 *     Equality returns Rem
	 *     Equality.Equality_1_0 returns Rem
	 *     Comparison returns Rem
	 *     Comparison.Comparison_1_0 returns Rem
	 *     Shift returns Rem
	 *     Shift.Shift_1_0 returns Rem
	 *     PlusOrMinus returns Rem
	 *     PlusOrMinus.Plus_1_0_0_0 returns Rem
	 *     PlusOrMinus.Minus_1_0_1_0 returns Rem
	 *     MulOrDiv returns Rem
	 *     MulOrDiv.Mul_1_0_0_0 returns Rem
	 *     MulOrDiv.Div_1_0_1_0 returns Rem
	 *     MulOrDiv.Rem_1_0_2_0 returns Rem
	 *     Primary returns Rem
	 *     Parameter returns Rem
	 *
	 * Constraint:
	 *     (left=MulOrDiv_Rem_1_0_2_0 right=Primary)
	 */
	protected void sequence_MulOrDiv(ISerializationContext context, Rem semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.REM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.REM__LEFT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.REM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.REM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMulOrDivAccess().getRemLeftAction_1_0_2_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMulOrDivAccess().getRightPrimaryParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Or
	 *     Expression returns Or
	 *     Assignment returns Or
	 *     Assignment.Assignment_1_0 returns Or
	 *     Ternary returns Or
	 *     Ternary.Ternary_1_0 returns Or
	 *     Or returns Or
	 *     Or.Or_1_0 returns Or
	 *     And returns Or
	 *     And.And_1_0 returns Or
	 *     BitOr returns Or
	 *     BitOr.BitOr_1_0 returns Or
	 *     BitXor returns Or
	 *     BitXor.BitXor_1_0 returns Or
	 *     BitAnd returns Or
	 *     BitAnd.BitAnd_1_0 returns Or
	 *     Equality returns Or
	 *     Equality.Equality_1_0 returns Or
	 *     Comparison returns Or
	 *     Comparison.Comparison_1_0 returns Or
	 *     Shift returns Or
	 *     Shift.Shift_1_0 returns Or
	 *     PlusOrMinus returns Or
	 *     PlusOrMinus.Plus_1_0_0_0 returns Or
	 *     PlusOrMinus.Minus_1_0_1_0 returns Or
	 *     MulOrDiv returns Or
	 *     MulOrDiv.Mul_1_0_0_0 returns Or
	 *     MulOrDiv.Div_1_0_1_0 returns Or
	 *     MulOrDiv.Rem_1_0_2_0 returns Or
	 *     Primary returns Or
	 *     Parameter returns Or
	 *
	 * Constraint:
	 *     (left=Or_Or_1_0 right=And)
	 */
	protected void sequence_Or(ISerializationContext context, Or semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.OR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.OR__LEFT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.OR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.OR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOrAccess().getOrLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getOrAccess().getRightAndParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Minus
	 *     Expression returns Minus
	 *     Assignment returns Minus
	 *     Assignment.Assignment_1_0 returns Minus
	 *     Ternary returns Minus
	 *     Ternary.Ternary_1_0 returns Minus
	 *     Or returns Minus
	 *     Or.Or_1_0 returns Minus
	 *     And returns Minus
	 *     And.And_1_0 returns Minus
	 *     BitOr returns Minus
	 *     BitOr.BitOr_1_0 returns Minus
	 *     BitXor returns Minus
	 *     BitXor.BitXor_1_0 returns Minus
	 *     BitAnd returns Minus
	 *     BitAnd.BitAnd_1_0 returns Minus
	 *     Equality returns Minus
	 *     Equality.Equality_1_0 returns Minus
	 *     Comparison returns Minus
	 *     Comparison.Comparison_1_0 returns Minus
	 *     Shift returns Minus
	 *     Shift.Shift_1_0 returns Minus
	 *     PlusOrMinus returns Minus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Minus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Minus
	 *     MulOrDiv returns Minus
	 *     MulOrDiv.Mul_1_0_0_0 returns Minus
	 *     MulOrDiv.Div_1_0_1_0 returns Minus
	 *     MulOrDiv.Rem_1_0_2_0 returns Minus
	 *     Primary returns Minus
	 *     Parameter returns Minus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Minus_1_0_1_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Minus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.MINUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.MINUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.MINUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.MINUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getMinusLeftAction_1_0_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Plus
	 *     Expression returns Plus
	 *     Assignment returns Plus
	 *     Assignment.Assignment_1_0 returns Plus
	 *     Ternary returns Plus
	 *     Ternary.Ternary_1_0 returns Plus
	 *     Or returns Plus
	 *     Or.Or_1_0 returns Plus
	 *     And returns Plus
	 *     And.And_1_0 returns Plus
	 *     BitOr returns Plus
	 *     BitOr.BitOr_1_0 returns Plus
	 *     BitXor returns Plus
	 *     BitXor.BitXor_1_0 returns Plus
	 *     BitAnd returns Plus
	 *     BitAnd.BitAnd_1_0 returns Plus
	 *     Equality returns Plus
	 *     Equality.Equality_1_0 returns Plus
	 *     Comparison returns Plus
	 *     Comparison.Comparison_1_0 returns Plus
	 *     Shift returns Plus
	 *     Shift.Shift_1_0 returns Plus
	 *     PlusOrMinus returns Plus
	 *     PlusOrMinus.Plus_1_0_0_0 returns Plus
	 *     PlusOrMinus.Minus_1_0_1_0 returns Plus
	 *     MulOrDiv returns Plus
	 *     MulOrDiv.Mul_1_0_0_0 returns Plus
	 *     MulOrDiv.Div_1_0_1_0 returns Plus
	 *     MulOrDiv.Rem_1_0_2_0 returns Plus
	 *     Primary returns Plus
	 *     Parameter returns Plus
	 *
	 * Constraint:
	 *     (left=PlusOrMinus_Plus_1_0_0_0 right=MulOrDiv)
	 */
	protected void sequence_PlusOrMinus(ISerializationContext context, Plus semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.PLUS__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.PLUS__LEFT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.PLUS__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.PLUS__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getPlusLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getPlusOrMinusAccess().getRightMulOrDivParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns BitNot
	 *     Expression returns BitNot
	 *     Assignment returns BitNot
	 *     Assignment.Assignment_1_0 returns BitNot
	 *     Ternary returns BitNot
	 *     Ternary.Ternary_1_0 returns BitNot
	 *     Or returns BitNot
	 *     Or.Or_1_0 returns BitNot
	 *     And returns BitNot
	 *     And.And_1_0 returns BitNot
	 *     BitOr returns BitNot
	 *     BitOr.BitOr_1_0 returns BitNot
	 *     BitXor returns BitNot
	 *     BitXor.BitXor_1_0 returns BitNot
	 *     BitAnd returns BitNot
	 *     BitAnd.BitAnd_1_0 returns BitNot
	 *     Equality returns BitNot
	 *     Equality.Equality_1_0 returns BitNot
	 *     Comparison returns BitNot
	 *     Comparison.Comparison_1_0 returns BitNot
	 *     Shift returns BitNot
	 *     Shift.Shift_1_0 returns BitNot
	 *     PlusOrMinus returns BitNot
	 *     PlusOrMinus.Plus_1_0_0_0 returns BitNot
	 *     PlusOrMinus.Minus_1_0_1_0 returns BitNot
	 *     MulOrDiv returns BitNot
	 *     MulOrDiv.Mul_1_0_0_0 returns BitNot
	 *     MulOrDiv.Div_1_0_1_0 returns BitNot
	 *     MulOrDiv.Rem_1_0_2_0 returns BitNot
	 *     Primary returns BitNot
	 *     Parameter returns BitNot
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, BitNot semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.BIT_NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.BIT_NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_2_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Not
	 *     Expression returns Not
	 *     Assignment returns Not
	 *     Assignment.Assignment_1_0 returns Not
	 *     Ternary returns Not
	 *     Ternary.Ternary_1_0 returns Not
	 *     Or returns Not
	 *     Or.Or_1_0 returns Not
	 *     And returns Not
	 *     And.And_1_0 returns Not
	 *     BitOr returns Not
	 *     BitOr.BitOr_1_0 returns Not
	 *     BitXor returns Not
	 *     BitXor.BitXor_1_0 returns Not
	 *     BitAnd returns Not
	 *     BitAnd.BitAnd_1_0 returns Not
	 *     Equality returns Not
	 *     Equality.Equality_1_0 returns Not
	 *     Comparison returns Not
	 *     Comparison.Comparison_1_0 returns Not
	 *     Shift returns Not
	 *     Shift.Shift_1_0 returns Not
	 *     PlusOrMinus returns Not
	 *     PlusOrMinus.Plus_1_0_0_0 returns Not
	 *     PlusOrMinus.Minus_1_0_1_0 returns Not
	 *     MulOrDiv returns Not
	 *     MulOrDiv.Mul_1_0_0_0 returns Not
	 *     MulOrDiv.Div_1_0_1_0 returns Not
	 *     MulOrDiv.Rem_1_0_2_0 returns Not
	 *     Primary returns Not
	 *     Parameter returns Not
	 *
	 * Constraint:
	 *     expression=Primary
	 */
	protected void sequence_Primary(ISerializationContext context, Not semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.NOT__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.NOT__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPrimaryAccess().getExpressionPrimaryParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Sequence returns Sequence
	 *
	 * Constraint:
	 *     ((name=ID | disable=DEC | pname=STRING | info=STRING)* codeblocks+=CodeBlock*)
	 */
	protected void sequence_Sequence(ISerializationContext context, Sequence semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Sequences returns Sequences
	 *
	 * Constraint:
	 *     sequences+=Sequence*
	 */
	protected void sequence_Sequences(ISerializationContext context, Sequences semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Shift
	 *     Expression returns Shift
	 *     Assignment returns Shift
	 *     Assignment.Assignment_1_0 returns Shift
	 *     Ternary returns Shift
	 *     Ternary.Ternary_1_0 returns Shift
	 *     Or returns Shift
	 *     Or.Or_1_0 returns Shift
	 *     And returns Shift
	 *     And.And_1_0 returns Shift
	 *     BitOr returns Shift
	 *     BitOr.BitOr_1_0 returns Shift
	 *     BitXor returns Shift
	 *     BitXor.BitXor_1_0 returns Shift
	 *     BitAnd returns Shift
	 *     BitAnd.BitAnd_1_0 returns Shift
	 *     Equality returns Shift
	 *     Equality.Equality_1_0 returns Shift
	 *     Comparison returns Shift
	 *     Comparison.Comparison_1_0 returns Shift
	 *     Shift returns Shift
	 *     Shift.Shift_1_0 returns Shift
	 *     PlusOrMinus returns Shift
	 *     PlusOrMinus.Plus_1_0_0_0 returns Shift
	 *     PlusOrMinus.Minus_1_0_1_0 returns Shift
	 *     MulOrDiv returns Shift
	 *     MulOrDiv.Mul_1_0_0_0 returns Shift
	 *     MulOrDiv.Div_1_0_1_0 returns Shift
	 *     MulOrDiv.Rem_1_0_2_0 returns Shift
	 *     Primary returns Shift
	 *     Parameter returns Shift
	 *
	 * Constraint:
	 *     (left=Shift_Shift_1_0 (op='&lt;&lt;' | op='&gt;&gt;') right=PlusOrMinus)
	 */
	protected void sequence_Shift(ISerializationContext context, Shift semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns Ternary
	 *     Expression returns Ternary
	 *     Assignment returns Ternary
	 *     Assignment.Assignment_1_0 returns Ternary
	 *     Ternary returns Ternary
	 *     Ternary.Ternary_1_0 returns Ternary
	 *     Or returns Ternary
	 *     Or.Or_1_0 returns Ternary
	 *     And returns Ternary
	 *     And.And_1_0 returns Ternary
	 *     BitOr returns Ternary
	 *     BitOr.BitOr_1_0 returns Ternary
	 *     BitXor returns Ternary
	 *     BitXor.BitXor_1_0 returns Ternary
	 *     BitAnd returns Ternary
	 *     BitAnd.BitAnd_1_0 returns Ternary
	 *     Equality returns Ternary
	 *     Equality.Equality_1_0 returns Ternary
	 *     Comparison returns Ternary
	 *     Comparison.Comparison_1_0 returns Ternary
	 *     Shift returns Ternary
	 *     Shift.Shift_1_0 returns Ternary
	 *     PlusOrMinus returns Ternary
	 *     PlusOrMinus.Plus_1_0_0_0 returns Ternary
	 *     PlusOrMinus.Minus_1_0_1_0 returns Ternary
	 *     MulOrDiv returns Ternary
	 *     MulOrDiv.Mul_1_0_0_0 returns Ternary
	 *     MulOrDiv.Div_1_0_1_0 returns Ternary
	 *     MulOrDiv.Rem_1_0_2_0 returns Ternary
	 *     Primary returns Ternary
	 *     Parameter returns Ternary
	 *
	 * Constraint:
	 *     (left=Ternary_Ternary_1_0 exp1=Expression exp2=Ternary)
	 */
	protected void sequence_Ternary(ISerializationContext context, Ternary semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.TERNARY__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.TERNARY__LEFT));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.TERNARY__EXP1) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.TERNARY__EXP1));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.TERNARY__EXP2) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.TERNARY__EXP2));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTernaryAccess().getTernaryLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getTernaryAccess().getExp1ExpressionParserRuleCall_1_2_0(), semanticObject.getExp1());
		feeder.accept(grammarAccess.getTernaryAccess().getExp2TernaryParserRuleCall_1_4_0(), semanticObject.getExp2());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Statement returns VariableDeclaration
	 *     VariableDeclaration returns VariableDeclaration
	 *
	 * Constraint:
	 *     (name=ID value=Expression)
	 */
	protected void sequence_VariableDeclaration(ISerializationContext context, VariableDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.VARIABLE_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.VARIABLE_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, DebugSeqPackage.Literals.VARIABLE_DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DebugSeqPackage.Literals.VARIABLE_DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getVariableDeclarationAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
}
